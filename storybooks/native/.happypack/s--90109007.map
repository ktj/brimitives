{"version":3,"sources":["node_modules/react-native/Libraries/Lists/VirtualizeUtils.js"],"names":["invariant","require","elementsThatOverlapOffsets","offsets","itemCount","getFrameMetrics","out","ii","frame","trailingOffset","offset","length","kk","JSON","stringify","newRangeCount","prev","next","last","first","Math","max","min","computeWindowedRenderLimits","props","getFrameMetricsApprox","scrollMetrics","data","getItemCount","maxToRenderPerBatch","windowSize","velocity","visibleLength","visibleBegin","visibleEnd","overscanLength","leadFactor","fillPreference","overscanBegin","overscanEnd","overscanFirst","overscanLast","visible","newCellCount","maxNewCells","firstWillAddMore","firstShouldIncrement","lastWillAddMore","lastShouldIncrement","Error","VirtualizeUtils","module","exports"],"mappings":"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","file":"VirtualizeUtils.js","sourceRoot":"/home/phz/workspace/brimitives/storybooks/native","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule VirtualizeUtils\n * @flow\n * @format\n */\n'use strict';\n\nconst invariant = require('fbjs/lib/invariant');\n\n/**\n * Used to find the indices of the frames that overlap the given offsets. Useful for finding the\n * items that bound different windows of content, such as the visible area or the buffered overscan\n * area.\n */\nfunction elementsThatOverlapOffsets(\n  offsets: Array<number>,\n  itemCount: number,\n  getFrameMetrics: (index: number) => {length: number, offset: number},\n): Array<number> {\n  const out = [];\n  for (let ii = 0; ii < itemCount; ii++) {\n    const frame = getFrameMetrics(ii);\n    const trailingOffset = frame.offset + frame.length;\n    for (let kk = 0; kk < offsets.length; kk++) {\n      if (out[kk] == null && trailingOffset >= offsets[kk]) {\n        out[kk] = ii;\n        if (kk === offsets.length - 1) {\n          invariant(\n            out.length === offsets.length,\n            'bad offsets input, should be in increasing order ' +\n              JSON.stringify(offsets),\n          );\n          return out;\n        }\n      }\n    }\n  }\n  return out;\n}\n\n/**\n * Computes the number of elements in the `next` range that are new compared to the `prev` range.\n * Handy for calculating how many new items will be rendered when the render window changes so we\n * can restrict the number of new items render at once so that content can appear on the screen\n * faster.\n */\nfunction newRangeCount(\n  prev: {first: number, last: number},\n  next: {first: number, last: number},\n): number {\n  return (\n    next.last -\n    next.first +\n    1 -\n    Math.max(\n      0,\n      1 + Math.min(next.last, prev.last) - Math.max(next.first, prev.first),\n    )\n  );\n}\n\n/**\n * Custom logic for determining which items should be rendered given the current frame and scroll\n * metrics, as well as the previous render state. The algorithm may evolve over time, but generally\n * prioritizes the visible area first, then expands that with overscan regions ahead and behind,\n * biased in the direction of scroll.\n */\nfunction computeWindowedRenderLimits(\n  props: {\n    data: any,\n    getItemCount: (data: any) => number,\n    maxToRenderPerBatch: number,\n    windowSize: number,\n  },\n  prev: {first: number, last: number},\n  getFrameMetricsApprox: (index: number) => {length: number, offset: number},\n  scrollMetrics: {\n    dt: number,\n    offset: number,\n    velocity: number,\n    visibleLength: number,\n  },\n): {first: number, last: number} {\n  const {data, getItemCount, maxToRenderPerBatch, windowSize} = props;\n  const itemCount = getItemCount(data);\n  if (itemCount === 0) {\n    return prev;\n  }\n  const {offset, velocity, visibleLength} = scrollMetrics;\n\n  // Start with visible area, then compute maximum overscan region by expanding from there, biased\n  // in the direction of scroll. Total overscan area is capped, which should cap memory consumption\n  // too.\n  const visibleBegin = Math.max(0, offset);\n  const visibleEnd = visibleBegin + visibleLength;\n  const overscanLength = (windowSize - 1) * visibleLength;\n\n  // Considering velocity seems to introduce more churn than it's worth.\n  const leadFactor = 0.5; // Math.max(0, Math.min(1, velocity / 25 + 0.5));\n\n  const fillPreference =\n    velocity > 1 ? 'after' : velocity < -1 ? 'before' : 'none';\n\n  const overscanBegin = Math.max(\n    0,\n    visibleBegin - (1 - leadFactor) * overscanLength,\n  );\n  const overscanEnd = Math.max(0, visibleEnd + leadFactor * overscanLength);\n\n  // Find the indices that correspond to the items at the render boundaries we're targetting.\n  let [overscanFirst, first, last, overscanLast] = elementsThatOverlapOffsets(\n    [overscanBegin, visibleBegin, visibleEnd, overscanEnd],\n    props.getItemCount(props.data),\n    getFrameMetricsApprox,\n  );\n  overscanFirst = overscanFirst == null ? 0 : overscanFirst;\n  first = first == null ? Math.max(0, overscanFirst) : first;\n  overscanLast = overscanLast == null ? itemCount - 1 : overscanLast;\n  last =\n    last == null\n      ? Math.min(overscanLast, first + maxToRenderPerBatch - 1)\n      : last;\n  const visible = {first, last};\n\n  // We want to limit the number of new cells we're rendering per batch so that we can fill the\n  // content on the screen quickly. If we rendered the entire overscan window at once, the user\n  // could be staring at white space for a long time waiting for a bunch of offscreen content to\n  // render.\n  let newCellCount = newRangeCount(prev, visible);\n\n  while (true) {\n    if (first <= overscanFirst && last >= overscanLast) {\n      // If we fill the entire overscan range, we're done.\n      break;\n    }\n    const maxNewCells = newCellCount >= maxToRenderPerBatch;\n    const firstWillAddMore = first <= prev.first || first > prev.last;\n    const firstShouldIncrement =\n      first > overscanFirst && (!maxNewCells || !firstWillAddMore);\n    const lastWillAddMore = last >= prev.last || last < prev.first;\n    const lastShouldIncrement =\n      last < overscanLast && (!maxNewCells || !lastWillAddMore);\n    if (maxNewCells && !firstShouldIncrement && !lastShouldIncrement) {\n      // We only want to stop if we've hit maxNewCells AND we cannot increment first or last\n      // without rendering new items. This let's us preserve as many already rendered items as\n      // possible, reducing render churn and keeping the rendered overscan range as large as\n      // possible.\n      break;\n    }\n    if (\n      firstShouldIncrement &&\n      !(fillPreference === 'after' && lastShouldIncrement && lastWillAddMore)\n    ) {\n      if (firstWillAddMore) {\n        newCellCount++;\n      }\n      first--;\n    }\n    if (\n      lastShouldIncrement &&\n      !(fillPreference === 'before' && firstShouldIncrement && firstWillAddMore)\n    ) {\n      if (lastWillAddMore) {\n        newCellCount++;\n      }\n      last++;\n    }\n  }\n  if (\n    !(\n      last >= first &&\n      first >= 0 &&\n      last < itemCount &&\n      first >= overscanFirst &&\n      last <= overscanLast &&\n      first <= visible.first &&\n      last >= visible.last\n    )\n  ) {\n    throw new Error(\n      'Bad window calculation ' +\n        JSON.stringify({\n          first,\n          last,\n          itemCount,\n          overscanFirst,\n          overscanLast,\n          visible,\n        }),\n    );\n  }\n  return {first, last};\n}\n\nconst VirtualizeUtils = {\n  computeWindowedRenderLimits,\n  elementsThatOverlapOffsets,\n  newRangeCount,\n};\n\nmodule.exports = VirtualizeUtils;\n"]}