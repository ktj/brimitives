{"version":3,"sources":["node_modules/react-native/Libraries/Storage/AsyncStorage.js"],"names":["NativeModules","require","RCTAsyncStorage","AsyncRocksDBStorage","AsyncSQLiteDBStorage","AsyncLocalStorage","AsyncStorage","_getRequests","_getKeys","_immediate","getItem","key","callback","Promise","resolve","reject","multiGet","errors","result","value","errs","convertErrors","setItem","multiSet","removeItem","multiRemove","mergeItem","multiMerge","clear","error","convertError","getAllKeys","keys","flushGetRequests","getRequests","getKeys","map","forEach","reqLength","length","i","request","requestKeys","requestResult","setImmediate","getRequest","keyIndex","promiseResult","push","indexOf","keyValuePairs","Array","isArray","e","out","Error","message","module","exports"],"mappings":"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","file":"AsyncStorage.js","sourceRoot":"/home/phz/workspace/brimitives/storybooks/native","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule AsyncStorage\n * @noflow\n * @flow-weak\n * @jsdoc\n */\n'use strict';\n\nconst NativeModules = require('NativeModules');\n\n// Use RocksDB if available, then SQLite, then file storage.\nconst RCTAsyncStorage = NativeModules.AsyncRocksDBStorage ||\n  NativeModules.AsyncSQLiteDBStorage ||\n  NativeModules.AsyncLocalStorage;\n\n/**\n * @class\n * @description\n * `AsyncStorage` is a simple, unencrypted, asynchronous, persistent, key-value storage\n * system that is global to the app.  It should be used instead of LocalStorage.\n *\n * It is recommended that you use an abstraction on top of `AsyncStorage`\n * instead of `AsyncStorage` directly for anything more than light usage since\n * it operates globally.\n *\n * On iOS, `AsyncStorage` is backed by native code that stores small values in a\n * serialized dictionary and larger values in separate files. On Android,\n * `AsyncStorage` will use either [RocksDB](http://rocksdb.org/) or SQLite\n * based on what is available.\n *\n * The `AsyncStorage` JavaScript code is a simple facade that provides a clear\n * JavaScript API, real `Error` objects, and simple non-multi functions. Each\n * method in the API returns a `Promise` object.\n *\n * Persisting data:\n * ```\n * try {\n *   await AsyncStorage.setItem('@MySuperStore:key', 'I like to save it.');\n * } catch (error) {\n *   // Error saving data\n * }\n * ```\n *\n * Fetching data:\n * ```\n * try {\n *   const value = await AsyncStorage.getItem('@MySuperStore:key');\n *   if (value !== null){\n *     // We have data!!\n *     console.log(value);\n *   }\n * } catch (error) {\n *   // Error retrieving data\n * }\n * ```\n */\nvar AsyncStorage = {\n  _getRequests: ([]: Array<any>),\n  _getKeys: ([]: Array<string>),\n  _immediate: (null: ?number),\n\n  /**\n   * Fetches an item for a `key` and invokes a callback upon completion.\n   * Returns a `Promise` object.\n   * @param key Key of the item to fetch.\n   * @param callback Function that will be called with a result if found or\n   *    any error.\n   * @returns A `Promise` object.\n   */\n  getItem: function(\n    key: string,\n    callback?: ?(error: ?Error, result: ?string) => void\n  ): Promise {\n    return new Promise((resolve, reject) => {\n      RCTAsyncStorage.multiGet([key], function(errors, result) {\n        // Unpack result to get value from [[key,value]]\n        var value = (result && result[0] && result[0][1]) ? result[0][1] : null;\n        var errs = convertErrors(errors);\n        callback && callback(errs && errs[0], value);\n        if (errs) {\n          reject(errs[0]);\n        } else {\n          resolve(value);\n        }\n      });\n    });\n  },\n\n  /**\n   * Sets the value for a `key` and invokes a callback upon completion.\n   * Returns a `Promise` object.\n   * @param key Key of the item to set.\n   * @param value Value to set for the `key`.\n   * @param callback Function that will be called with any error.\n   * @returns A `Promise` object.\n   */\n  setItem: function(\n    key: string,\n    value: string,\n    callback?: ?(error: ?Error) => void\n  ): Promise {\n    return new Promise((resolve, reject) => {\n      RCTAsyncStorage.multiSet([[key,value]], function(errors) {\n        var errs = convertErrors(errors);\n        callback && callback(errs && errs[0]);\n        if (errs) {\n          reject(errs[0]);\n        } else {\n          resolve(null);\n        }\n      });\n    });\n  },\n\n  /**\n   * Removes an item for a `key` and invokes a callback upon completion.\n   * Returns a `Promise` object.\n   * @param key Key of the item to remove.\n   * @param callback Function that will be called with any error.\n   * @returns A `Promise` object.\n   */\n  removeItem: function(\n    key: string,\n    callback?: ?(error: ?Error) => void\n  ): Promise {\n    return new Promise((resolve, reject) => {\n      RCTAsyncStorage.multiRemove([key], function(errors) {\n        var errs = convertErrors(errors);\n        callback && callback(errs && errs[0]);\n        if (errs) {\n          reject(errs[0]);\n        } else {\n          resolve(null);\n        }\n      });\n    });\n  },\n\n  /**\n   * Merges an existing `key` value with an input value, assuming both values\n   * are stringified JSON. Returns a `Promise` object.\n   *\n   * **NOTE:** This is not supported by all native implementations.\n   *\n   * @param key Key of the item to modify.\n   * @param value New value to merge for the `key`.\n   * @param callback Function that will be called with any error.\n   * @returns A `Promise` object.\n   *\n   * @example <caption>Example</caption>\n   * let UID123_object = {\n   *  name: 'Chris',\n   *  age: 30,\n   *  traits: {hair: 'brown', eyes: 'brown'},\n   * };\n   * // You only need to define what will be added or updated\n   * let UID123_delta = {\n   *  age: 31,\n   *  traits: {eyes: 'blue', shoe_size: 10}\n   * };\n   *\n   * AsyncStorage.setItem('UID123', JSON.stringify(UID123_object), () => {\n   *   AsyncStorage.mergeItem('UID123', JSON.stringify(UID123_delta), () => {\n   *     AsyncStorage.getItem('UID123', (err, result) => {\n   *       console.log(result);\n   *     });\n   *   });\n   * });\n   *\n   * // Console log result:\n   * // => {'name':'Chris','age':31,'traits':\n   * //    {'shoe_size':10,'hair':'brown','eyes':'blue'}}\n   */\n  mergeItem: function(\n    key: string,\n    value: string,\n    callback?: ?(error: ?Error) => void\n  ): Promise {\n    return new Promise((resolve, reject) => {\n      RCTAsyncStorage.multiMerge([[key,value]], function(errors) {\n        var errs = convertErrors(errors);\n        callback && callback(errs && errs[0]);\n        if (errs) {\n          reject(errs[0]);\n        } else {\n          resolve(null);\n        }\n      });\n    });\n  },\n\n  /**\n   * Erases *all* `AsyncStorage` for all clients, libraries, etc.  You probably\n   * don't want to call this; use `removeItem` or `multiRemove` to clear only\n   * your app's keys. Returns a `Promise` object.\n   * @param callback Function that will be called with any error.\n   * @returns A `Promise` object.\n   */\n  clear: function(callback?: ?(error: ?Error) => void): Promise {\n    return new Promise((resolve, reject) => {\n      RCTAsyncStorage.clear(function(error) {\n        callback && callback(convertError(error));\n        if (error && convertError(error)){\n          reject(convertError(error));\n        } else {\n          resolve(null);\n        }\n      });\n    });\n  },\n\n  /**\n   * Gets *all* keys known to your app; for all callers, libraries, etc.\n   * Returns a `Promise` object.\n   * @param callback Function that will be called the keys found and any error.\n   * @returns A `Promise` object.\n   *\n   * Example: see the `multiGet` example.\n   */\n  getAllKeys: function(callback?: ?(error: ?Error, keys: ?Array<string>) => void): Promise {\n    return new Promise((resolve, reject) => {\n      RCTAsyncStorage.getAllKeys(function(error, keys) {\n        callback && callback(convertError(error), keys);\n        if (error) {\n          reject(convertError(error));\n        } else {\n          resolve(keys);\n        }\n      });\n    });\n  },\n\n  /**\n   * The following batched functions are useful for executing a lot of\n   * operations at once, allowing for native optimizations and provide the\n   * convenience of a single callback after all operations are complete.\n   *\n   * These functions return arrays of errors, potentially one for every key.\n   * For key-specific errors, the Error object will have a key property to\n   * indicate which key caused the error.\n   */\n\n  /** Flushes any pending requests using a single batch call to get the data. */\n  flushGetRequests: function(): void {\n    const getRequests = this._getRequests;\n    const getKeys = this._getKeys;\n\n    this._getRequests = [];\n    this._getKeys = [];\n\n    RCTAsyncStorage.multiGet(getKeys, function(errors, result) {\n      // Even though the runtime complexity of this is theoretically worse vs if we used a map,\n      // it's much, much faster in practice for the data sets we deal with (we avoid\n      // allocating result pair arrays). This was heavily benchmarked.\n      //\n      // Is there a way to avoid using the map but fix the bug in this breaking test?\n      // https://github.com/facebook/react-native/commit/8dd8ad76579d7feef34c014d387bf02065692264\n      const map = {};\n      result && result.forEach(([key, value]) => { map[key] = value; return value; });\n      const reqLength = getRequests.length;\n      for (let i = 0; i < reqLength; i++) {\n        const request = getRequests[i];\n        const requestKeys = request.keys;\n        const requestResult = requestKeys.map(key => [key, map[key]]);\n        request.callback && request.callback(null, requestResult);\n        request.resolve && request.resolve(requestResult);\n      }\n    });\n  },\n\n  /**\n   * This allows you to batch the fetching of items given an array of `key`\n   * inputs. Your callback will be invoked with an array of corresponding\n   * key-value pairs found:\n   *\n   * ```\n   * multiGet(['k1', 'k2'], cb) -> cb([['k1', 'val1'], ['k2', 'val2']])\n   * ```\n   *\n   * The method returns a `Promise` object.\n   *\n   * @param keys Array of key for the items to get.\n   * @param callback Function that will be called with a key-value array of\n   *     the results, plus an array of any key-specific errors found.\n   * @returns A `Promise` object.\n   *\n   * @example <caption>Example</caption>\n   *\n   * AsyncStorage.getAllKeys((err, keys) => {\n   *   AsyncStorage.multiGet(keys, (err, stores) => {\n   *    stores.map((result, i, store) => {\n   *      // get at each store's key/value so you can work with it\n   *      let key = store[i][0];\n   *      let value = store[i][1];\n   *     });\n   *   });\n   * });\n   */\n  multiGet: function(\n    keys: Array<string>,\n    callback?: ?(errors: ?Array<Error>, result: ?Array<Array<string>>) => void\n  ): Promise {\n    if (!this._immediate) {\n      this._immediate = setImmediate(() => {\n        this._immediate = null;\n        this.flushGetRequests();\n      });\n    }\n\n    var getRequest = {\n      keys: keys,\n      callback: callback,\n      // do we need this?\n      keyIndex: this._getKeys.length,\n      resolve: null,\n      reject: null,\n    };\n\n    var promiseResult = new Promise((resolve, reject) => {\n      getRequest.resolve = resolve;\n      getRequest.reject = reject;\n    });\n\n    this._getRequests.push(getRequest);\n    // avoid fetching duplicates\n    keys.forEach(key => {\n      if (this._getKeys.indexOf(key) === -1) {\n        this._getKeys.push(key);\n      }\n    });\n\n    return promiseResult;\n  },\n\n  /**\n   * Use this as a batch operation for storing multiple key-value pairs. When\n   * the operation completes you'll get a single callback with any errors:\n   *\n   * ```\n   * multiSet([['k1', 'val1'], ['k2', 'val2']], cb);\n   * ```\n   *\n   * The method returns a `Promise` object.\n   *\n   * @param keyValuePairs Array of key-value array for the items to set.\n   * @param callback Function that will be called with an array of any\n   *    key-specific errors found.\n   * @returns A `Promise` object.\n   * Example: see the `multiMerge` example.\n   */\n  multiSet: function(\n    keyValuePairs: Array<Array<string>>,\n    callback?: ?(errors: ?Array<Error>) => void\n  ): Promise {\n    return new Promise((resolve, reject) => {\n      RCTAsyncStorage.multiSet(keyValuePairs, function(errors) {\n        var error = convertErrors(errors);\n        callback && callback(error);\n        if (error) {\n          reject(error);\n        } else {\n          resolve(null);\n        }\n      });\n    });\n  },\n\n  /**\n   * Call this to batch the deletion of all keys in the `keys` array. Returns\n   * a `Promise` object.\n   *\n   * @param keys Array of key for the items to delete.\n   * @param callback Function that will be called an array of any key-specific\n   *    errors found.\n   * @returns A `Promise` object.\n   *\n   * @example <caption>Example</caption>\n   * let keys = ['k1', 'k2'];\n   * AsyncStorage.multiRemove(keys, (err) => {\n   *   // keys k1 & k2 removed, if they existed\n   *   // do most stuff after removal (if you want)\n   * });\n   */\n  multiRemove: function(\n    keys: Array<string>,\n    callback?: ?(errors: ?Array<Error>) => void\n  ): Promise {\n    return new Promise((resolve, reject) => {\n      RCTAsyncStorage.multiRemove(keys, function(errors) {\n        var error = convertErrors(errors);\n        callback && callback(error);\n        if (error) {\n          reject(error);\n        } else {\n          resolve(null);\n        }\n      });\n    });\n  },\n\n  /**\n   * Batch operation to merge in existing and new values for a given set of\n   * keys. This assumes that the values are stringified JSON. Returns a\n   * `Promise` object.\n   *\n   * **NOTE**: This is not supported by all native implementations.\n   *\n   * @param keyValuePairs Array of key-value array for the items to merge.\n   * @param callback Function that will be called with an array of any\n   *    key-specific errors found.\n   * @returns A `Promise` object.\n   *\n   * @example <caption>Example</caption>\n   * // first user, initial values\n   * let UID234_object = {\n   *  name: 'Chris',\n   *  age: 30,\n   *  traits: {hair: 'brown', eyes: 'brown'},\n   * };\n   *\n   * // first user, delta values\n   * let UID234_delta = {\n   *  age: 31,\n   *  traits: {eyes: 'blue', shoe_size: 10},\n   * };\n   *\n   * // second user, initial values\n   * let UID345_object = {\n   *  name: 'Marge',\n   *  age: 25,\n   *  traits: {hair: 'blonde', eyes: 'blue'},\n   * };\n   *\n   * // second user, delta values\n   * let UID345_delta = {\n   *  age: 26,\n   *  traits: {eyes: 'green', shoe_size: 6},\n   * };\n   *\n   * let multi_set_pairs   = [['UID234', JSON.stringify(UID234_object)], ['UID345', JSON.stringify(UID345_object)]]\n   * let multi_merge_pairs = [['UID234', JSON.stringify(UID234_delta)], ['UID345', JSON.stringify(UID345_delta)]]\n   *\n   * AsyncStorage.multiSet(multi_set_pairs, (err) => {\n   *   AsyncStorage.multiMerge(multi_merge_pairs, (err) => {\n   *     AsyncStorage.multiGet(['UID234','UID345'], (err, stores) => {\n   *       stores.map( (result, i, store) => {\n   *         let key = store[i][0];\n   *         let val = store[i][1];\n   *         console.log(key, val);\n   *       });\n   *     });\n   *   });\n   * });\n   *\n   * // Console log results:\n   * // => UID234 {\"name\":\"Chris\",\"age\":31,\"traits\":{\"shoe_size\":10,\"hair\":\"brown\",\"eyes\":\"blue\"}}\n   * // => UID345 {\"name\":\"Marge\",\"age\":26,\"traits\":{\"shoe_size\":6,\"hair\":\"blonde\",\"eyes\":\"green\"}}\n   */\n  multiMerge: function(\n    keyValuePairs: Array<Array<string>>,\n    callback?: ?(errors: ?Array<Error>) => void\n  ): Promise {\n    return new Promise((resolve, reject) => {\n      RCTAsyncStorage.multiMerge(keyValuePairs, function(errors) {\n        var error = convertErrors(errors);\n        callback && callback(error);\n        if (error) {\n          reject(error);\n        } else {\n          resolve(null);\n        }\n      });\n    });\n  },\n};\n\n// Not all native implementations support merge.\nif (!RCTAsyncStorage.multiMerge) {\n  delete AsyncStorage.mergeItem;\n  delete AsyncStorage.multiMerge;\n}\n\nfunction convertErrors(errs) {\n  if (!errs) {\n    return null;\n  }\n  return (Array.isArray(errs) ? errs : [errs]).map((e) => convertError(e));\n}\n\nfunction convertError(error) {\n  if (!error) {\n    return null;\n  }\n  var out = new Error(error.message);\n  out.key = error.key; // flow doesn't like this :(\n  return out;\n}\n\nmodule.exports = AsyncStorage;\n"]}