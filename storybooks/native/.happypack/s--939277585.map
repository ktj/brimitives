{"version":3,"sources":["node_modules/react-native/Libraries/Components/Touchable/Touchable.js"],"names":["BoundingDimensions","require","Platform","Position","React","ReactNative","TVEventHandler","TouchEventUtils","UIManager","View","keyMirror","normalizeColor","States","NOT_RESPONDER","RESPONDER_INACTIVE_PRESS_IN","RESPONDER_INACTIVE_PRESS_OUT","RESPONDER_ACTIVE_PRESS_IN","RESPONDER_ACTIVE_PRESS_OUT","RESPONDER_ACTIVE_LONG_PRESS_IN","RESPONDER_ACTIVE_LONG_PRESS_OUT","ERROR","IsActive","IsPressingIn","IsLongPressingIn","Signals","DELAY","RESPONDER_GRANT","RESPONDER_RELEASE","RESPONDER_TERMINATED","ENTER_PRESS_RECT","LEAVE_PRESS_RECT","LONG_PRESS_DETECTED","Transitions","error","HIGHLIGHT_DELAY_MS","PRESS_EXPAND_PX","LONG_PRESS_THRESHOLD","LONG_PRESS_DELAY_MS","LONG_PRESS_ALLOWED_MOVEMENT","TouchableMixin","componentDidMount","isTVOS","_tvEventHandler","enable","cmp","evt","myTag","findNodeHandle","dispatchConfig","tag","eventType","touchableHandleActivePressIn","touchableHandleActivePressOut","touchableHandlePress","componentWillUnmount","disable","touchableDelayTimeout","clearTimeout","longPressDelayTimeout","pressOutDelayTimeout","touchableGetInitialState","touchable","touchState","undefined","responderID","touchableHandleResponderTerminationRequest","props","rejectResponderTermination","touchableHandleStartShouldSetResponder","disabled","touchableLongPressCancelsPress","touchableHandleResponderGrant","e","dispatchID","currentTarget","persist","state","_receiveSignal","delayMS","touchableGetHighlightDelayMS","Math","max","isNaN","setTimeout","_handleDelay","bind","longDelayMS","touchableGetLongPressDelayMS","_handleLongDelay","touchableHandleResponderRelease","touchableHandleResponderTerminate","touchableHandleResponderMove","positionOnActivate","dimensionsOnActivate","pressRectOffset","touchableGetPressRectOffset","left","right","top","bottom","pressExpandLeft","pressExpandTop","pressExpandRight","pressExpandBottom","hitSlop","touchableGetHitSlop","touch","extractSingleTouch","nativeEvent","pageX","pageY","pressInLocation","movedDistance","_getDistanceBetweenPoints","_cancelLongPressDelayTimeout","isTouchWithinActive","width","height","curState","_remeasureMetricsOnActivation","measure","_handleQueryLayout","l","t","w","h","globalX","globalY","release","getPooled","console","signal","nextState","Error","_performSideEffectsForTransition","_isHighlight","_savePressInLocation","locationX","locationY","aX","aY","bX","bY","deltaX","deltaY","sqrt","curIsHighlight","newIsHighlight","isFinalSignal","touchableHandleLongPress","_startHighlight","_endHighlight","hasLongPressHandler","onLongPress","pressIsLongButStillCallOnPress","shouldInvokePress","touchableGetPressOutDelayMS","Touchable","Mixin","TOUCH_TARGET_DEBUG","renderDebugView","color","__DEV__","debugHitSlopStyle","key","hexColor","toString","substr","position","borderColor","slice","borderWidth","borderStyle","backgroundColor","module","exports"],"mappings":"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","file":"Touchable.js","sourceRoot":"/home/phz/workspace/brimitives/storybooks/native","sourcesContent":["/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule Touchable\n */\n\n'use strict';\n\nconst BoundingDimensions = require('BoundingDimensions');\nconst Platform = require('Platform');\nconst Position = require('Position');\nconst React = require('React');\nconst ReactNative = require('ReactNative');\nconst TVEventHandler = require('TVEventHandler');\nconst TouchEventUtils = require('fbjs/lib/TouchEventUtils');\nconst UIManager = require('UIManager');\nconst View = require('View');\n\nconst keyMirror = require('fbjs/lib/keyMirror');\nconst normalizeColor = require('normalizeColor');\n\n/**\n * `Touchable`: Taps done right.\n *\n * You hook your `ResponderEventPlugin` events into `Touchable`. `Touchable`\n * will measure time/geometry and tells you when to give feedback to the user.\n *\n * ====================== Touchable Tutorial ===============================\n * The `Touchable` mixin helps you handle the \"press\" interaction. It analyzes\n * the geometry of elements, and observes when another responder (scroll view\n * etc) has stolen the touch lock. It notifies your component when it should\n * give feedback to the user. (bouncing/highlighting/unhighlighting).\n *\n * - When a touch was activated (typically you highlight)\n * - When a touch was deactivated (typically you unhighlight)\n * - When a touch was \"pressed\" - a touch ended while still within the geometry\n *   of the element, and no other element (like scroller) has \"stolen\" touch\n *   lock (\"responder\") (Typically you bounce the element).\n *\n * A good tap interaction isn't as simple as you might think. There should be a\n * slight delay before showing a highlight when starting a touch. If a\n * subsequent touch move exceeds the boundary of the element, it should\n * unhighlight, but if that same touch is brought back within the boundary, it\n * should rehighlight again. A touch can move in and out of that boundary\n * several times, each time toggling highlighting, but a \"press\" is only\n * triggered if that touch ends while within the element's boundary and no\n * scroller (or anything else) has stolen the lock on touches.\n *\n * To create a new type of component that handles interaction using the\n * `Touchable` mixin, do the following:\n *\n * - Initialize the `Touchable` state.\n *\n *   getInitialState: function() {\n *     return merge(this.touchableGetInitialState(), yourComponentState);\n *   }\n *\n * - Choose the rendered component who's touches should start the interactive\n *   sequence. On that rendered node, forward all `Touchable` responder\n *   handlers. You can choose any rendered node you like. Choose a node whose\n *   hit target you'd like to instigate the interaction sequence:\n *\n *   // In render function:\n *   return (\n *     <View\n *       onStartShouldSetResponder={this.touchableHandleStartShouldSetResponder}\n *       onResponderTerminationRequest={this.touchableHandleResponderTerminationRequest}\n *       onResponderGrant={this.touchableHandleResponderGrant}\n *       onResponderMove={this.touchableHandleResponderMove}\n *       onResponderRelease={this.touchableHandleResponderRelease}\n *       onResponderTerminate={this.touchableHandleResponderTerminate}>\n *       <View>\n *         Even though the hit detection/interactions are triggered by the\n *         wrapping (typically larger) node, we usually end up implementing\n *         custom logic that highlights this inner one.\n *       </View>\n *     </View>\n *   );\n *\n * - You may set up your own handlers for each of these events, so long as you\n *   also invoke the `touchable*` handlers inside of your custom handler.\n *\n * - Implement the handlers on your component class in order to provide\n *   feedback to the user. See documentation for each of these class methods\n *   that you should implement.\n *\n *   touchableHandlePress: function() {\n *      this.performBounceAnimation();  // or whatever you want to do.\n *   },\n *   touchableHandleActivePressIn: function() {\n *     this.beginHighlighting(...);  // Whatever you like to convey activation\n *   },\n *   touchableHandleActivePressOut: function() {\n *     this.endHighlighting(...);  // Whatever you like to convey deactivation\n *   },\n *\n * - There are more advanced methods you can implement (see documentation below):\n *   touchableGetHighlightDelayMS: function() {\n *     return 20;\n *   }\n *   // In practice, *always* use a predeclared constant (conserve memory).\n *   touchableGetPressRectOffset: function() {\n *     return {top: 20, left: 20, right: 20, bottom: 100};\n *   }\n */\n\n/**\n * Touchable states.\n */\nvar States = keyMirror({\n  NOT_RESPONDER: null,                   // Not the responder\n  RESPONDER_INACTIVE_PRESS_IN: null,     // Responder, inactive, in the `PressRect`\n  RESPONDER_INACTIVE_PRESS_OUT: null,    // Responder, inactive, out of `PressRect`\n  RESPONDER_ACTIVE_PRESS_IN: null,       // Responder, active, in the `PressRect`\n  RESPONDER_ACTIVE_PRESS_OUT: null,      // Responder, active, out of `PressRect`\n  RESPONDER_ACTIVE_LONG_PRESS_IN: null,  // Responder, active, in the `PressRect`, after long press threshold\n  RESPONDER_ACTIVE_LONG_PRESS_OUT: null, // Responder, active, out of `PressRect`, after long press threshold\n  ERROR: null\n});\n\n/**\n * Quick lookup map for states that are considered to be \"active\"\n */\nvar IsActive = {\n  RESPONDER_ACTIVE_PRESS_OUT: true,\n  RESPONDER_ACTIVE_PRESS_IN: true\n};\n\n/**\n * Quick lookup for states that are considered to be \"pressing\" and are\n * therefore eligible to result in a \"selection\" if the press stops.\n */\nvar IsPressingIn = {\n  RESPONDER_INACTIVE_PRESS_IN: true,\n  RESPONDER_ACTIVE_PRESS_IN: true,\n  RESPONDER_ACTIVE_LONG_PRESS_IN: true,\n};\n\nvar IsLongPressingIn = {\n  RESPONDER_ACTIVE_LONG_PRESS_IN: true,\n};\n\n/**\n * Inputs to the state machine.\n */\nvar Signals = keyMirror({\n  DELAY: null,\n  RESPONDER_GRANT: null,\n  RESPONDER_RELEASE: null,\n  RESPONDER_TERMINATED: null,\n  ENTER_PRESS_RECT: null,\n  LEAVE_PRESS_RECT: null,\n  LONG_PRESS_DETECTED: null,\n});\n\n/**\n * Mapping from States x Signals => States\n */\nvar Transitions = {\n  NOT_RESPONDER: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.RESPONDER_INACTIVE_PRESS_IN,\n    RESPONDER_RELEASE: States.ERROR,\n    RESPONDER_TERMINATED: States.ERROR,\n    ENTER_PRESS_RECT: States.ERROR,\n    LEAVE_PRESS_RECT: States.ERROR,\n    LONG_PRESS_DETECTED: States.ERROR,\n  },\n  RESPONDER_INACTIVE_PRESS_IN: {\n    DELAY: States.RESPONDER_ACTIVE_PRESS_IN,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.ERROR,\n  },\n  RESPONDER_INACTIVE_PRESS_OUT: {\n    DELAY: States.RESPONDER_ACTIVE_PRESS_OUT,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.ERROR,\n  },\n  RESPONDER_ACTIVE_PRESS_IN: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.RESPONDER_ACTIVE_LONG_PRESS_IN,\n  },\n  RESPONDER_ACTIVE_PRESS_OUT: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.ERROR,\n  },\n  RESPONDER_ACTIVE_LONG_PRESS_IN: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.RESPONDER_ACTIVE_LONG_PRESS_IN,\n  },\n  RESPONDER_ACTIVE_LONG_PRESS_OUT: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.ERROR,\n  },\n  error: {\n    DELAY: States.NOT_RESPONDER,\n    RESPONDER_GRANT: States.RESPONDER_INACTIVE_PRESS_IN,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.NOT_RESPONDER,\n    LEAVE_PRESS_RECT: States.NOT_RESPONDER,\n    LONG_PRESS_DETECTED: States.NOT_RESPONDER,\n  }\n};\n\n// ==== Typical Constants for integrating into UI components ====\n// var HIT_EXPAND_PX = 20;\n// var HIT_VERT_OFFSET_PX = 10;\nvar HIGHLIGHT_DELAY_MS = 130;\n\nvar PRESS_EXPAND_PX = 20;\n\nvar LONG_PRESS_THRESHOLD = 500;\n\nvar LONG_PRESS_DELAY_MS = LONG_PRESS_THRESHOLD - HIGHLIGHT_DELAY_MS;\n\nvar LONG_PRESS_ALLOWED_MOVEMENT = 10;\n\n// Default amount \"active\" region protrudes beyond box\n\n/**\n * By convention, methods prefixed with underscores are meant to be @private,\n * and not @protected. Mixers shouldn't access them - not even to provide them\n * as callback handlers.\n *\n *\n * ========== Geometry =========\n * `Touchable` only assumes that there exists a `HitRect` node. The `PressRect`\n * is an abstract box that is extended beyond the `HitRect`.\n *\n *  +--------------------------+\n *  |                          | - \"Start\" events in `HitRect` cause `HitRect`\n *  |  +--------------------+  |   to become the responder.\n *  |  |  +--------------+  |  | - `HitRect` is typically expanded around\n *  |  |  |              |  |  |   the `VisualRect`, but shifted downward.\n *  |  |  |  VisualRect  |  |  | - After pressing down, after some delay,\n *  |  |  |              |  |  |   and before letting up, the Visual React\n *  |  |  +--------------+  |  |   will become \"active\". This makes it eligible\n *  |  |     HitRect        |  |   for being highlighted (so long as the\n *  |  +--------------------+  |   press remains in the `PressRect`).\n *  |        PressRect     o   |\n *  +----------------------|---+\n *           Out Region    |\n *                         +-----+ This gap between the `HitRect` and\n *                                 `PressRect` allows a touch to move far away\n *                                 from the original hit rect, and remain\n *                                 highlighted, and eligible for a \"Press\".\n *                                 Customize this via\n *                                 `touchableGetPressRectOffset()`.\n *\n *\n *\n * ======= State Machine =======\n *\n * +-------------+ <---+ RESPONDER_RELEASE\n * |NOT_RESPONDER|\n * +-------------+ <---+ RESPONDER_TERMINATED\n *     +\n *     | RESPONDER_GRANT (HitRect)\n *     v\n * +---------------------------+  DELAY   +-------------------------+  T + DELAY     +------------------------------+\n * |RESPONDER_INACTIVE_PRESS_IN|+-------->|RESPONDER_ACTIVE_PRESS_IN| +------------> |RESPONDER_ACTIVE_LONG_PRESS_IN|\n * +---------------------------+          +-------------------------+                +------------------------------+\n *     +            ^                         +           ^                                 +           ^\n *     |LEAVE_      |ENTER_                   |LEAVE_     |ENTER_                           |LEAVE_     |ENTER_\n *     |PRESS_RECT  |PRESS_RECT               |PRESS_RECT |PRESS_RECT                       |PRESS_RECT |PRESS_RECT\n *     |            |                         |           |                                 |           |\n *     v            +                         v           +                                 v           +\n * +----------------------------+  DELAY  +--------------------------+               +-------------------------------+\n * |RESPONDER_INACTIVE_PRESS_OUT|+------->|RESPONDER_ACTIVE_PRESS_OUT|               |RESPONDER_ACTIVE_LONG_PRESS_OUT|\n * +----------------------------+         +--------------------------+               +-------------------------------+\n *\n * T + DELAY => LONG_PRESS_DELAY_MS + DELAY\n *\n * Not drawn are the side effects of each transition. The most important side\n * effect is the `touchableHandlePress` abstract method invocation that occurs\n * when a responder is released while in either of the \"Press\" states.\n *\n * The other important side effects are the highlight abstract method\n * invocations (internal callbacks) to be implemented by the mixer.\n *\n *\n * @lends Touchable.prototype\n */\nvar TouchableMixin = {\n  componentDidMount: function() {\n    if (!Platform.isTVOS) {\n      return;\n    }\n\n    this._tvEventHandler = new TVEventHandler();\n    this._tvEventHandler.enable(this, function(cmp, evt) {\n      var myTag = ReactNative.findNodeHandle(cmp);\n      evt.dispatchConfig = {};\n      if (myTag === evt.tag) {\n        if (evt.eventType === 'focus') {\n          cmp.touchableHandleActivePressIn && cmp.touchableHandleActivePressIn(evt);\n        } else if (evt.eventType === 'blur') {\n          cmp.touchableHandleActivePressOut && cmp.touchableHandleActivePressOut(evt);\n        } else if (evt.eventType === 'select') {\n          cmp.touchableHandlePress && cmp.touchableHandlePress(evt);\n        }\n      }\n    });\n  },\n\n  /**\n   * Clear all timeouts on unmount\n   */\n  componentWillUnmount: function() {\n    if (this._tvEventHandler) {\n      this._tvEventHandler.disable();\n      delete this._tvEventHandler;\n    }\n    this.touchableDelayTimeout && clearTimeout(this.touchableDelayTimeout);\n    this.longPressDelayTimeout && clearTimeout(this.longPressDelayTimeout);\n    this.pressOutDelayTimeout && clearTimeout(this.pressOutDelayTimeout);\n  },\n\n  /**\n   * It's prefer that mixins determine state in this way, having the class\n   * explicitly mix the state in the one and only `getInitialState` method.\n   *\n   * @return {object} State object to be placed inside of\n   * `this.state.touchable`.\n   */\n  touchableGetInitialState: function() {\n    return {\n      touchable: {touchState: undefined, responderID: null}\n    };\n  },\n\n  // ==== Hooks to Gesture Responder system ====\n  /**\n   * Must return true if embedded in a native platform scroll view.\n   */\n  touchableHandleResponderTerminationRequest: function() {\n    return !this.props.rejectResponderTermination;\n  },\n\n  /**\n   * Must return true to start the process of `Touchable`.\n   */\n  touchableHandleStartShouldSetResponder: function() {\n    return !this.props.disabled;\n  },\n\n  /**\n   * Return true to cancel press on long press.\n   */\n  touchableLongPressCancelsPress: function () {\n    return true;\n  },\n\n  /**\n   * Place as callback for a DOM element's `onResponderGrant` event.\n   * @param {SyntheticEvent} e Synthetic event from event system.\n   *\n   */\n  touchableHandleResponderGrant: function(e) {\n    var dispatchID = e.currentTarget;\n    // Since e is used in a callback invoked on another event loop\n    // (as in setTimeout etc), we need to call e.persist() on the\n    // event to make sure it doesn't get reused in the event object pool.\n    e.persist();\n\n    this.pressOutDelayTimeout && clearTimeout(this.pressOutDelayTimeout);\n    this.pressOutDelayTimeout = null;\n\n    this.state.touchable.touchState = States.NOT_RESPONDER;\n    this.state.touchable.responderID = dispatchID;\n    this._receiveSignal(Signals.RESPONDER_GRANT, e);\n    var delayMS =\n      this.touchableGetHighlightDelayMS !== undefined ?\n      Math.max(this.touchableGetHighlightDelayMS(), 0) : HIGHLIGHT_DELAY_MS;\n    delayMS = isNaN(delayMS) ? HIGHLIGHT_DELAY_MS : delayMS;\n    if (delayMS !== 0) {\n      this.touchableDelayTimeout = setTimeout(\n        this._handleDelay.bind(this, e),\n        delayMS\n      );\n    } else {\n      this._handleDelay(e);\n    }\n\n    var longDelayMS =\n      this.touchableGetLongPressDelayMS !== undefined ?\n      Math.max(this.touchableGetLongPressDelayMS(), 10) : LONG_PRESS_DELAY_MS;\n    longDelayMS = isNaN(longDelayMS) ? LONG_PRESS_DELAY_MS : longDelayMS;\n    this.longPressDelayTimeout = setTimeout(\n      this._handleLongDelay.bind(this, e),\n      longDelayMS + delayMS\n    );\n  },\n\n  /**\n   * Place as callback for a DOM element's `onResponderRelease` event.\n   */\n  touchableHandleResponderRelease: function(e) {\n    this._receiveSignal(Signals.RESPONDER_RELEASE, e);\n  },\n\n  /**\n   * Place as callback for a DOM element's `onResponderTerminate` event.\n   */\n  touchableHandleResponderTerminate: function(e) {\n    this._receiveSignal(Signals.RESPONDER_TERMINATED, e);\n  },\n\n  /**\n   * Place as callback for a DOM element's `onResponderMove` event.\n   */\n  touchableHandleResponderMove: function(e) {\n    // Not enough time elapsed yet, wait for highlight -\n    // this is just a perf optimization.\n    if (this.state.touchable.touchState === States.RESPONDER_INACTIVE_PRESS_IN) {\n      return;\n    }\n\n    // Measurement may not have returned yet.\n    if (!this.state.touchable.positionOnActivate) {\n      return;\n    }\n\n    var positionOnActivate = this.state.touchable.positionOnActivate;\n    var dimensionsOnActivate = this.state.touchable.dimensionsOnActivate;\n    var pressRectOffset = this.touchableGetPressRectOffset ?\n      this.touchableGetPressRectOffset() : {\n        left: PRESS_EXPAND_PX,\n        right: PRESS_EXPAND_PX,\n        top: PRESS_EXPAND_PX,\n        bottom: PRESS_EXPAND_PX\n      };\n\n    var pressExpandLeft = pressRectOffset.left;\n    var pressExpandTop = pressRectOffset.top;\n    var pressExpandRight = pressRectOffset.right;\n    var pressExpandBottom = pressRectOffset.bottom;\n\n    var hitSlop = this.touchableGetHitSlop ?\n      this.touchableGetHitSlop() : null;\n\n    if (hitSlop) {\n      pressExpandLeft += hitSlop.left;\n      pressExpandTop += hitSlop.top;\n      pressExpandRight += hitSlop.right;\n      pressExpandBottom += hitSlop.bottom;\n    }\n\n    var touch = TouchEventUtils.extractSingleTouch(e.nativeEvent);\n    var pageX = touch && touch.pageX;\n    var pageY = touch && touch.pageY;\n\n    if (this.pressInLocation) {\n      var movedDistance = this._getDistanceBetweenPoints(pageX, pageY, this.pressInLocation.pageX, this.pressInLocation.pageY);\n      if (movedDistance > LONG_PRESS_ALLOWED_MOVEMENT) {\n        this._cancelLongPressDelayTimeout();\n      }\n    }\n\n    var isTouchWithinActive =\n        pageX > positionOnActivate.left - pressExpandLeft &&\n        pageY > positionOnActivate.top - pressExpandTop &&\n        pageX <\n          positionOnActivate.left +\n          dimensionsOnActivate.width +\n          pressExpandRight &&\n        pageY <\n          positionOnActivate.top +\n          dimensionsOnActivate.height +\n          pressExpandBottom;\n    if (isTouchWithinActive) {\n      this._receiveSignal(Signals.ENTER_PRESS_RECT, e);\n      var curState = this.state.touchable.touchState;\n      if (curState === States.RESPONDER_INACTIVE_PRESS_IN) {\n        // fix for t7967420\n        this._cancelLongPressDelayTimeout();\n      }\n    } else {\n      this._cancelLongPressDelayTimeout();\n      this._receiveSignal(Signals.LEAVE_PRESS_RECT, e);\n    }\n  },\n\n  // ==== Abstract Application Callbacks ====\n\n  /**\n   * Invoked when the item should be highlighted. Mixers should implement this\n   * to visually distinguish the `VisualRect` so that the user knows that\n   * releasing a touch will result in a \"selection\" (analog to click).\n   *\n   * @abstract\n   * touchableHandleActivePressIn: function,\n   */\n\n  /**\n   * Invoked when the item is \"active\" (in that it is still eligible to become\n   * a \"select\") but the touch has left the `PressRect`. Usually the mixer will\n   * want to unhighlight the `VisualRect`. If the user (while pressing) moves\n   * back into the `PressRect` `touchableHandleActivePressIn` will be invoked\n   * again and the mixer should probably highlight the `VisualRect` again. This\n   * event will not fire on an `touchEnd/mouseUp` event, only move events while\n   * the user is depressing the mouse/touch.\n   *\n   * @abstract\n   * touchableHandleActivePressOut: function\n   */\n\n  /**\n   * Invoked when the item is \"selected\" - meaning the interaction ended by\n   * letting up while the item was either in the state\n   * `RESPONDER_ACTIVE_PRESS_IN` or `RESPONDER_INACTIVE_PRESS_IN`.\n   *\n   * @abstract\n   * touchableHandlePress: function\n   */\n\n  /**\n   * Invoked when the item is long pressed - meaning the interaction ended by\n   * letting up while the item was in `RESPONDER_ACTIVE_LONG_PRESS_IN`. If\n   * `touchableHandleLongPress` is *not* provided, `touchableHandlePress` will\n   * be called as it normally is. If `touchableHandleLongPress` is provided, by\n   * default any `touchableHandlePress` callback will not be invoked. To\n   * override this default behavior, override `touchableLongPressCancelsPress`\n   * to return false. As a result, `touchableHandlePress` will be called when\n   * lifting up, even if `touchableHandleLongPress` has also been called.\n   *\n   * @abstract\n   * touchableHandleLongPress: function\n   */\n\n  /**\n   * Returns the number of millis to wait before triggering a highlight.\n   *\n   * @abstract\n   * touchableGetHighlightDelayMS: function\n   */\n\n  /**\n   * Returns the amount to extend the `HitRect` into the `PressRect`. Positive\n   * numbers mean the size expands outwards.\n   *\n   * @abstract\n   * touchableGetPressRectOffset: function\n   */\n\n\n\n  // ==== Internal Logic ====\n\n  /**\n   * Measures the `HitRect` node on activation. The Bounding rectangle is with\n   * respect to viewport - not page, so adding the `pageXOffset/pageYOffset`\n   * should result in points that are in the same coordinate system as an\n   * event's `globalX/globalY` data values.\n   *\n   * - Consider caching this for the lifetime of the component, or possibly\n   *   being able to share this cache between any `ScrollMap` view.\n   *\n   * @sideeffects\n   * @private\n   */\n  _remeasureMetricsOnActivation: function() {\n    const tag = this.state.touchable.responderID;\n    if (tag == null) {\n      return;\n    }\n\n    UIManager.measure(tag, this._handleQueryLayout);\n  },\n\n  _handleQueryLayout: function(l, t, w, h, globalX, globalY) {\n    //don't do anything UIManager failed to measure node\n    if (!l && !t && !w && !h && !globalX && !globalY) {\n      return;\n    }\n    this.state.touchable.positionOnActivate &&\n      Position.release(this.state.touchable.positionOnActivate);\n    this.state.touchable.dimensionsOnActivate &&\n      BoundingDimensions.release(this.state.touchable.dimensionsOnActivate);\n    this.state.touchable.positionOnActivate = Position.getPooled(globalX, globalY);\n    this.state.touchable.dimensionsOnActivate = BoundingDimensions.getPooled(w, h);\n  },\n\n  _handleDelay: function(e) {\n    this.touchableDelayTimeout = null;\n    this._receiveSignal(Signals.DELAY, e);\n  },\n\n  _handleLongDelay: function(e) {\n    this.longPressDelayTimeout = null;\n    var curState = this.state.touchable.touchState;\n    if (curState !== States.RESPONDER_ACTIVE_PRESS_IN &&\n        curState !== States.RESPONDER_ACTIVE_LONG_PRESS_IN) {\n      console.error('Attempted to transition from state `' + curState + '` to `' +\n        States.RESPONDER_ACTIVE_LONG_PRESS_IN + '`, which is not supported. This is ' +\n        'most likely due to `Touchable.longPressDelayTimeout` not being cancelled.');\n    } else {\n      this._receiveSignal(Signals.LONG_PRESS_DETECTED, e);\n    }\n  },\n\n  /**\n   * Receives a state machine signal, performs side effects of the transition\n   * and stores the new state. Validates the transition as well.\n   *\n   * @param {Signals} signal State machine signal.\n   * @throws Error if invalid state transition or unrecognized signal.\n   * @sideeffects\n   */\n  _receiveSignal: function(signal, e) {\n    var responderID = this.state.touchable.responderID;\n    var curState = this.state.touchable.touchState;\n    var nextState = Transitions[curState] && Transitions[curState][signal];\n    if (!responderID && signal === Signals.RESPONDER_RELEASE) {\n      return;\n    }\n    if (!nextState) {\n      throw new Error(\n        'Unrecognized signal `' + signal + '` or state `' + curState +\n        '` for Touchable responder `' + responderID + '`'\n      );\n    }\n    if (nextState === States.ERROR) {\n      throw new Error(\n        'Touchable cannot transition from `' + curState + '` to `' + signal +\n        '` for responder `' + responderID + '`'\n      );\n    }\n    if (curState !== nextState) {\n      this._performSideEffectsForTransition(curState, nextState, signal, e);\n      this.state.touchable.touchState = nextState;\n    }\n  },\n\n  _cancelLongPressDelayTimeout: function () {\n    this.longPressDelayTimeout && clearTimeout(this.longPressDelayTimeout);\n    this.longPressDelayTimeout = null;\n  },\n\n  _isHighlight: function (state) {\n    return state === States.RESPONDER_ACTIVE_PRESS_IN ||\n           state === States.RESPONDER_ACTIVE_LONG_PRESS_IN;\n  },\n\n  _savePressInLocation: function(e) {\n    var touch = TouchEventUtils.extractSingleTouch(e.nativeEvent);\n    var pageX = touch && touch.pageX;\n    var pageY = touch && touch.pageY;\n    var locationX = touch && touch.locationX;\n    var locationY = touch && touch.locationY;\n    this.pressInLocation = {pageX, pageY, locationX, locationY};\n  },\n\n  _getDistanceBetweenPoints: function (aX, aY, bX, bY) {\n    var deltaX = aX - bX;\n    var deltaY = aY - bY;\n    return Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n  },\n\n  /**\n   * Will perform a transition between touchable states, and identify any\n   * highlighting or unhighlighting that must be performed for this particular\n   * transition.\n   *\n   * @param {States} curState Current Touchable state.\n   * @param {States} nextState Next Touchable state.\n   * @param {Signal} signal Signal that triggered the transition.\n   * @param {Event} e Native event.\n   * @sideeffects\n   */\n  _performSideEffectsForTransition: function(curState, nextState, signal, e) {\n    var curIsHighlight = this._isHighlight(curState);\n    var newIsHighlight = this._isHighlight(nextState);\n\n    var isFinalSignal =\n      signal === Signals.RESPONDER_TERMINATED ||\n      signal === Signals.RESPONDER_RELEASE;\n\n    if (isFinalSignal) {\n      this._cancelLongPressDelayTimeout();\n    }\n\n    if (!IsActive[curState] && IsActive[nextState]) {\n      this._remeasureMetricsOnActivation();\n    }\n\n    if (IsPressingIn[curState] && signal === Signals.LONG_PRESS_DETECTED) {\n      this.touchableHandleLongPress && this.touchableHandleLongPress(e);\n    }\n\n    if (newIsHighlight && !curIsHighlight) {\n      this._startHighlight(e);\n    } else if (!newIsHighlight && curIsHighlight) {\n      this._endHighlight(e);\n    }\n\n    if (IsPressingIn[curState] && signal === Signals.RESPONDER_RELEASE) {\n      var hasLongPressHandler = !!this.props.onLongPress;\n      var pressIsLongButStillCallOnPress =\n        IsLongPressingIn[curState] && (    // We *are* long pressing..\n          !hasLongPressHandler ||          // But either has no long handler\n          !this.touchableLongPressCancelsPress() // or we're told to ignore it.\n        );\n\n      var shouldInvokePress =  !IsLongPressingIn[curState] || pressIsLongButStillCallOnPress;\n      if (shouldInvokePress && this.touchableHandlePress) {\n        if (!newIsHighlight && !curIsHighlight) {\n          // we never highlighted because of delay, but we should highlight now\n          this._startHighlight(e);\n          this._endHighlight(e);\n        }\n        this.touchableHandlePress(e);\n      }\n    }\n\n    this.touchableDelayTimeout && clearTimeout(this.touchableDelayTimeout);\n    this.touchableDelayTimeout = null;\n  },\n\n  _startHighlight: function(e) {\n    this._savePressInLocation(e);\n    this.touchableHandleActivePressIn && this.touchableHandleActivePressIn(e);\n  },\n\n  _endHighlight: function(e) {\n    if (this.touchableHandleActivePressOut) {\n      if (this.touchableGetPressOutDelayMS && this.touchableGetPressOutDelayMS()) {\n        this.pressOutDelayTimeout = setTimeout(() => {\n          this.touchableHandleActivePressOut(e);\n        }, this.touchableGetPressOutDelayMS());\n      } else {\n        this.touchableHandleActivePressOut(e);\n      }\n    }\n  },\n\n};\n\nvar Touchable = {\n  Mixin: TouchableMixin,\n  TOUCH_TARGET_DEBUG: false, // Highlights all touchable targets. Toggle with Inspector.\n  /**\n   * Renders a debugging overlay to visualize touch target with hitSlop (might not work on Android).\n   */\n  renderDebugView: ({color, hitSlop}) => {\n    if (!Touchable.TOUCH_TARGET_DEBUG) {\n      return null;\n    }\n    if (!__DEV__) {\n      throw Error('Touchable.TOUCH_TARGET_DEBUG should not be enabled in prod!');\n    }\n    const debugHitSlopStyle = {};\n    hitSlop = hitSlop || {top: 0, bottom: 0, left: 0, right: 0};\n    for (const key in hitSlop) {\n      debugHitSlopStyle[key] = -hitSlop[key];\n    }\n    const hexColor = '#' + ('00000000' + normalizeColor(color).toString(16)).substr(-8);\n    return (\n      <View\n        pointerEvents=\"none\"\n        style={{\n          position: 'absolute',\n          borderColor: hexColor.slice(0, -2) + '55', // More opaque\n          borderWidth: 1,\n          borderStyle: 'dashed',\n          backgroundColor: hexColor.slice(0, -2) + '0F', // Less opaque\n          ...debugHitSlopStyle\n        }}\n      />\n    );\n  }\n};\n\nmodule.exports = Touchable;\n"]}