{"version":3,"sources":["node_modules/react-native/Libraries/AppState/AppState.js"],"names":["MissingNativeEventEmitterShim","require","NativeEventEmitter","NativeModules","RCTAppState","AppState","logError","invariant","isAvailable","_eventHandlers","change","Map","memoryWarning","currentState","initialAppState","addListener","appStateData","app_state","getCurrentAppState","type","handler","indexOf","set","has","get","remove","delete","__DEV__","MissingNativeAppStateShim","throwMissingNativeModule","module","exports"],"mappings":";;;;;;;;;;;AAWA,a;;AAEA,GAAMA,+BAAgCC,QAAQ,+BAAR,CAAtC;AACA,GAAMC,oBAAqBD,QAAQ,oBAAR,CAA3B;AACA,GAAME,eAAgBF,QAAQ,eAAR,CAAtB;AACA,GAAMG,aAAcD,cAAcE,QAAlC;;AAEA,GAAMC,UAAWL,QAAQ,UAAR,CAAjB;AACA,GAAMM,WAAYN,QAAQ,oBAAR,CAAlB,C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkEMI,Q;;;;;;AAMJ,mBAAc;AACND,WADM,SAFdI,WAEc,CAFS,IAET;;AAGZ,MAAKA,WAAL,CAAmB,IAAnB;AACA,MAAKC,cAAL,CAAsB;AACpBC,OAAQ,GAAIC,IAAJ,EADY;AAEpBC,cAAe,GAAID,IAAJ,EAFK,CAAtB;;;;;AAOA,MAAKE,YAAL,CAAoBT,YAAYU,eAAZ,EAA+B,QAAnD;;;;;;AAMA,MAAKC,WAAL;AACE,mBADF;AAEE,SAACC,YAAD,CAAkB;AAChB,MAAKH,YAAL,CAAoBG,aAAaC,SAAjC;AACD,CAJH;;;;;;AAUAb,YAAYc,kBAAZ;AACE,SAACF,YAAD,CAAkB;AAChB,MAAKH,YAAL,CAAoBG,aAAaC,SAAjC;AACD,CAHH;AAIEX,QAJF,EA3BY;;AAiCb,C;;;;;;;;;;;;;AAaCa,I;AACAC,O;AACA;AACAb;AACE,CAAC,QAAD,CAAW,eAAX,EAA4Bc,OAA5B,CAAoCF,IAApC,IAA8C,CAAC,CADjD;AAEE,4CAFF,CAEgDA,IAFhD;;AAIA,GAAIA,OAAS,QAAb,CAAuB;AACrB,KAAKV,cAAL,CAAoBU,IAApB,EAA0BG,GAA1B,CAA8BF,OAA9B,CAAuC,KAAKL,WAAL;AACrC,mBADqC;AAErC,SAACC,YAAD,CAAkB;AAChBI,QAAQJ,aAAaC,SAArB;AACD,CAJoC,CAAvC;;AAMD,CAPD,IAOO,IAAIE,OAAS,eAAb,CAA8B;AACnC,KAAKV,cAAL,CAAoBU,IAApB,EAA0BG,GAA1B,CAA8BF,OAA9B,CAAuC,KAAKL,WAAL;AACrC,eADqC;AAErCK,OAFqC,CAAvC;;AAID;AACF,C;;;;;;AAMCD,I;AACAC,O;AACA;AACAb;AACE,CAAC,QAAD,CAAW,eAAX,EAA4Bc,OAA5B,CAAoCF,IAApC,IAA8C,CAAC,CADjD;AAEE,mDAFF,CAEuDA,IAFvD;;AAIA,GAAI,CAAC,KAAKV,cAAL,CAAoBU,IAApB,EAA0BI,GAA1B,CAA8BH,OAA9B,CAAL,CAA6C;AAC3C;AACD;AACD,KAAKX,cAAL,CAAoBU,IAApB,EAA0BK,GAA1B,CAA8BJ,OAA9B,EAAuCK,MAAvC;AACA,KAAKhB,cAAL,CAAoBU,IAApB,EAA0BO,MAA1B,CAAiCN,OAAjC;AACD,C,sBA1FoBlB,kB;;;AA6FvB,GAAIyB,SAAW,CAACvB,WAAhB,CAA6B;AACrBwB,yBADqB;AAEzB,oCAAc;AACN,aADM,CACS,UADT;AAEb,CAJwB;;;;;;AAUa;AACpC,KAAKC,wBAAL;AACD,CAZwB;;AAcgB;AACvC,KAAKA,wBAAL;AACD,CAhBwB,wCAMG,CAC1B,KAAKA,wBAAL,GACD,CARwB,uCACa7B,6BADb;;;;;;AAsB3BK,SAAW,GAAIuB,0BAAJ,EAAX;AACD,CAvBD,IAuBO;AACLvB,SAAW,GAAIA,SAAJ,EAAX;AACD;;AAEDyB,OAAOC,OAAP,CAAiB1B,QAAjB,C,0GA7LMD,W,0JAqEAC,Q","file":"AppState.js","sourceRoot":"/home/phz/workspace/brimitives/storybooks/native","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule AppState\n * @flow\n */\n'use strict';\n\nconst MissingNativeEventEmitterShim = require('MissingNativeEventEmitterShim');\nconst NativeEventEmitter = require('NativeEventEmitter');\nconst NativeModules = require('NativeModules');\nconst RCTAppState = NativeModules.AppState;\n\nconst logError = require('logError');\nconst invariant = require('fbjs/lib/invariant');\n\n/**\n * `AppState` can tell you if the app is in the foreground or background,\n * and notify you when the state changes.\n *\n * AppState is frequently used to determine the intent and proper behavior when\n * handling push notifications.\n *\n * ### App States\n *\n *  - `active` - The app is running in the foreground\n *  - `background` - The app is running in the background. The user is either\n *     in another app or on the home screen\n *  - `inactive` - This is a state that occurs when transitioning between\n *     foreground & background, and during periods of inactivity such as\n *     entering the Multitasking view or in the event of an incoming call\n *\n * For more information, see\n * [Apple's documentation](https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/TheAppLifeCycle/TheAppLifeCycle.html)\n *\n * ### Basic Usage\n *\n * To see the current state, you can check `AppState.currentState`, which\n * will be kept up-to-date. However, `currentState` will be null at launch\n * while `AppState` retrieves it over the bridge.\n *\n * ```\n * import React, {Component} from 'react'\n * import {AppState, Text} from 'react-native'\n *\n * class AppStateExample extends Component {\n *\n *   state = {\n *     appState: AppState.currentState\n *   }\n *\n *   componentDidMount() {\n *     AppState.addEventListener('change', this._handleAppStateChange);\n *   }\n *\n *   componentWillUnmount() {\n *     AppState.removeEventListener('change', this._handleAppStateChange);\n *   }\n *\n *   _handleAppStateChange = (nextAppState) => {\n *     if (this.state.appState.match(/inactive|background/) && nextAppState === 'active') {\n *       console.log('App has come to the foreground!')\n *     }\n *     this.setState({appState: nextAppState});\n *   }\n *\n *   render() {\n *     return (\n *       <Text>Current state is: {this.state.appState}</Text>\n *     );\n *   }\n *\n * }\n * ```\n *\n * This example will only ever appear to say \"Current state is: active\" because\n * the app is only visible to the user when in the `active` state, and the null\n * state will happen only momentarily.\n */\n\nclass AppState extends NativeEventEmitter {\n\n  _eventHandlers: Object;\n  currentState: ?string;\n  isAvailable: boolean = true;\n\n  constructor() {\n    super(RCTAppState);\n\n    this.isAvailable = true;\n    this._eventHandlers = {\n      change: new Map(),\n      memoryWarning: new Map(),\n    };\n\n    // TODO: Remove the 'active' fallback after `initialAppState` is exported by\n    // the Android implementation.\n    this.currentState = RCTAppState.initialAppState || 'active';\n\n    // TODO: this is a terrible solution - in order to ensure `currentState` prop\n    // is up to date, we have to register an observer that updates it whenever\n    // the state changes, even if nobody cares. We should just deprecate the\n    // `currentState` property and get rid of this.\n    this.addListener(\n      'appStateDidChange',\n      (appStateData) => {\n        this.currentState = appStateData.app_state;\n      }\n    );\n\n    // TODO: see above - this request just populates the value of `currentState`\n    // when the module is first initialized. Would be better to get rid of the prop\n    // and expose `getCurrentAppState` method directly.\n    RCTAppState.getCurrentAppState(\n      (appStateData) => {\n        this.currentState = appStateData.app_state;\n      },\n      logError\n    );\n  }\n\n  /**\n   * Add a handler to AppState changes by listening to the `change` event type\n   * and providing the handler\n   *\n   * TODO: now that AppState is a subclass of NativeEventEmitter, we could deprecate\n   * `addEventListener` and `removeEventListener` and just use `addListener` and\n   * `listener.remove()` directly. That will be a breaking change though, as both\n   * the method and event names are different (addListener events are currently\n   * required to be globally unique).\n   */\n  addEventListener(\n    type: string,\n    handler: Function\n  ) {\n    invariant(\n      ['change', 'memoryWarning'].indexOf(type) !== -1,\n      'Trying to subscribe to unknown event: \"%s\"', type\n    );\n    if (type === 'change') {\n      this._eventHandlers[type].set(handler, this.addListener(\n        'appStateDidChange',\n        (appStateData) => {\n          handler(appStateData.app_state);\n        }\n      ));\n    } else if (type === 'memoryWarning') {\n      this._eventHandlers[type].set(handler, this.addListener(\n        'memoryWarning',\n        handler\n      ));\n    }\n  }\n\n  /**\n   * Remove a handler by passing the `change` event type and the handler\n   */\n  removeEventListener(\n    type: string,\n    handler: Function\n  ) {\n    invariant(\n      ['change', 'memoryWarning'].indexOf(type) !== -1,\n      'Trying to remove listener for unknown event: \"%s\"', type\n    );\n    if (!this._eventHandlers[type].has(handler)) {\n      return;\n    }\n    this._eventHandlers[type].get(handler).remove();\n    this._eventHandlers[type].delete(handler);\n  }\n}\n\nif (__DEV__ && !RCTAppState) {\n  class MissingNativeAppStateShim extends MissingNativeEventEmitterShim {\n    constructor() {\n      super('RCTAppState', 'AppState');\n    }\n\n    get currentState(): ?string {\n      this.throwMissingNativeModule();\n    }\n\n    addEventListener(...args: Array<any>) {\n      this.throwMissingNativeModule();\n    }\n\n    removeEventListener(...args: Array<any>) {\n      this.throwMissingNativeModule();\n    }\n  }\n\n  // This module depends on the native `RCTAppState` module. If you don't include it,\n  // `AppState.isAvailable` will return `false`, and any method calls will throw.\n  // We reassign the class variable to keep the autodoc generator happy.\n  AppState = new MissingNativeAppStateShim();\n} else {\n  AppState = new AppState();\n}\n\nmodule.exports = AppState;\n"]}