{"version":3,"sources":["node_modules/react-native/Libraries/Interaction/InteractionManager.js"],"names":["BatchedBridge","require","EventEmitter","Set","TaskQueue","infoLog","invariant","keyMirror","_emitter","DEBUG_DELAY","DEBUG","InteractionManager","Events","interactionStart","interactionComplete","runAfterInteractions","task","tasks","promise","Promise","_scheduleUpdate","push","run","resolve","name","_taskQueue","enqueueTasks","then","bind","done","console","warn","cancel","cancelTasks","createInteractionHandle","handle","_inc","_addInteractionSet","add","clearInteractionHandle","delete","_deleteInteractionSet","addListener","setDeadline","deadline","_deadline","_interactionSet","onMoreTasks","_nextUpdateHandle","setTimeout","_processUpdate","setImmediate","interactionCount","size","forEach","nextInteractionCount","emit","hasTasksToProcess","processNext","getEventLoopRunningTime","clear","module","exports"],"mappings":"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","file":"InteractionManager.js","sourceRoot":"/home/phz/workspace/brimitives/storybooks/native","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule InteractionManager\n * @flow\n */\n'use strict';\n\nconst BatchedBridge = require('BatchedBridge');\nconst EventEmitter = require('EventEmitter');\nconst Set = require('Set');\nconst TaskQueue = require('TaskQueue');\n\nconst infoLog = require('infoLog');\nconst invariant = require('fbjs/lib/invariant');\nconst keyMirror = require('fbjs/lib/keyMirror');\n\ntype Handle = number;\nimport type {Task} from 'TaskQueue';\n\nconst _emitter = new EventEmitter();\n\nconst DEBUG_DELAY = 0;\nconst DEBUG = false;\n\n/**\n * InteractionManager allows long-running work to be scheduled after any\n * interactions/animations have completed. In particular, this allows JavaScript\n * animations to run smoothly.\n *\n * Applications can schedule tasks to run after interactions with the following:\n *\n * ```\n * InteractionManager.runAfterInteractions(() => {\n *   // ...long-running synchronous task...\n * });\n * ```\n *\n * Compare this to other scheduling alternatives:\n *\n * - requestAnimationFrame(): for code that animates a view over time.\n * - setImmediate/setTimeout(): run code later, note this may delay animations.\n * - runAfterInteractions(): run code later, without delaying active animations.\n *\n * The touch handling system considers one or more active touches to be an\n * 'interaction' and will delay `runAfterInteractions()` callbacks until all\n * touches have ended or been cancelled.\n *\n * InteractionManager also allows applications to register animations by\n * creating an interaction 'handle' on animation start, and clearing it upon\n * completion:\n *\n * ```\n * var handle = InteractionManager.createInteractionHandle();\n * // run animation... (`runAfterInteractions` tasks are queued)\n * // later, on animation completion:\n * InteractionManager.clearInteractionHandle(handle);\n * // queued tasks run if all handles were cleared\n * ```\n *\n * `runAfterInteractions` takes either a plain callback function, or a\n * `PromiseTask` object with a `gen` method that returns a `Promise`.  If a\n * `PromiseTask` is supplied, then it is fully resolved (including asynchronous\n * dependencies that also schedule more tasks via `runAfterInteractions`) before\n * starting on the next task that might have been queued up synchronously\n * earlier.\n *\n * By default, queued tasks are executed together in a loop in one\n * `setImmediate` batch. If `setDeadline` is called with a positive number, then\n * tasks will only be executed until the deadline (in terms of js event loop run\n * time) approaches, at which point execution will yield via setTimeout,\n * allowing events such as touches to start interactions and block queued tasks\n * from executing, making apps more responsive.\n */\nvar InteractionManager = {\n  Events: keyMirror({\n    interactionStart: true,\n    interactionComplete: true,\n  }),\n\n  /**\n   * Schedule a function to run after all interactions have completed. Returns a cancellable\n   * \"promise\".\n   */\n  runAfterInteractions(task: ?Task): {then: Function, done: Function, cancel: Function} {\n    const tasks = [];\n    const promise = new Promise(resolve => {\n      _scheduleUpdate();\n      if (task) {\n        tasks.push(task);\n      }\n      tasks.push({run: resolve, name: 'resolve ' + (task && task.name || '?')});\n      _taskQueue.enqueueTasks(tasks);\n    });\n    return {\n      then: promise.then.bind(promise),\n      done: (...args) => {\n        if (promise.done) {\n          return promise.done(...args);\n        } else {\n          console.warn('Tried to call done when not supported by current Promise implementation.');\n        }\n      },\n      cancel: function() {\n        _taskQueue.cancelTasks(tasks);\n      },\n    };\n  },\n\n  /**\n   * Notify manager that an interaction has started.\n   */\n  createInteractionHandle(): Handle {\n    DEBUG && infoLog('create interaction handle');\n    _scheduleUpdate();\n    var handle = ++_inc;\n    _addInteractionSet.add(handle);\n    return handle;\n  },\n\n  /**\n   * Notify manager that an interaction has completed.\n   */\n  clearInteractionHandle(handle: Handle) {\n    DEBUG && infoLog('clear interaction handle');\n    invariant(\n      !!handle,\n      'Must provide a handle to clear.'\n    );\n    _scheduleUpdate();\n    _addInteractionSet.delete(handle);\n    _deleteInteractionSet.add(handle);\n  },\n\n  addListener: _emitter.addListener.bind(_emitter),\n\n  /**\n   * A positive number will use setTimeout to schedule any tasks after the\n   * eventLoopRunningTime hits the deadline value, otherwise all tasks will be\n   * executed in one setImmediate batch (default).\n   */\n  setDeadline(deadline: number) {\n    _deadline = deadline;\n  },\n};\n\nconst _interactionSet = new Set();\nconst _addInteractionSet = new Set();\nconst _deleteInteractionSet = new Set();\nconst _taskQueue = new TaskQueue({onMoreTasks: _scheduleUpdate});\nlet _nextUpdateHandle = 0;\nlet _inc = 0;\nlet _deadline = -1;\n\ndeclare function setImmediate(callback: any, ...args: Array<any>): number;\n\n/**\n * Schedule an asynchronous update to the interaction state.\n */\nfunction _scheduleUpdate() {\n  if (!_nextUpdateHandle) {\n    if (_deadline > 0) {\n      _nextUpdateHandle = setTimeout(_processUpdate, 0 + DEBUG_DELAY);\n    } else {\n      _nextUpdateHandle = setImmediate(_processUpdate);\n    }\n  }\n}\n\n/**\n * Notify listeners, process queue, etc\n */\nfunction _processUpdate() {\n  _nextUpdateHandle = 0;\n\n  var interactionCount = _interactionSet.size;\n  _addInteractionSet.forEach(handle =>\n    _interactionSet.add(handle)\n  );\n  _deleteInteractionSet.forEach(handle =>\n    _interactionSet.delete(handle)\n  );\n  var nextInteractionCount = _interactionSet.size;\n\n  if (interactionCount !== 0 && nextInteractionCount === 0) {\n    // transition from 1+ --> 0 interactions\n    _emitter.emit(InteractionManager.Events.interactionComplete);\n  } else if (interactionCount === 0 && nextInteractionCount !== 0) {\n    // transition from 0 --> 1+ interactions\n    _emitter.emit(InteractionManager.Events.interactionStart);\n  }\n\n  // process the queue regardless of a transition\n  if (nextInteractionCount === 0) {\n    while (_taskQueue.hasTasksToProcess()) {\n      _taskQueue.processNext();\n      if (_deadline > 0 &&\n          BatchedBridge.getEventLoopRunningTime() >= _deadline) {\n        // Hit deadline before processing all tasks, so process more later.\n        _scheduleUpdate();\n        break;\n      }\n    }\n  }\n  _addInteractionSet.clear();\n  _deleteInteractionSet.clear();\n}\n\nmodule.exports = InteractionManager;\n"]}