{"version":3,"sources":["node_modules/react-native/Libraries/Animated/src/Interpolation.js"],"names":["invariant","require","normalizeColor","linear","t","Interpolation","config","outputRange","createInterpolationFromStringOutputRange","checkInfiniteRange","inputRange","checkValidInputRange","length","easing","extrapolateLeft","undefined","extrapolate","extrapolateRight","input","range","findRange","interpolate","inputMin","inputMax","outputMin","outputMax","result","Infinity","colorToRgba","int32Color","r","g","b","a","stringShapeRegex","map","checkPattern","outputRanges","match","forEach","value","number","i","push","interpolations","create","shouldRound","isRgbOrRgba","replace","val","rounded","Math","round","String","startsWith","arr","pattern","name","module","exports"],"mappings":"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","file":"Interpolation.js","sourceRoot":"/home/phz/workspace/brimitives/storybooks/native","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule Interpolation\n * @flow\n */\n/* eslint no-bitwise: 0 */\n'use strict';\n\nvar invariant = require('fbjs/lib/invariant');\nvar normalizeColor = require('normalizeColor');\n\ntype ExtrapolateType = 'extend' | 'identity' | 'clamp';\n\nexport type InterpolationConfigType = {\n  inputRange: Array<number>,\n  /* $FlowFixMe(>=0.38.0 site=react_native_fb,react_native_oss) - Flow error\n   * detected during the deployment of v0.38.0. To see the error, remove this\n   * comment and run flow\n   */\n  outputRange: (Array<number> | Array<string>),\n  easing?: ((input: number) => number),\n  extrapolate?: ExtrapolateType,\n  extrapolateLeft?: ExtrapolateType,\n  extrapolateRight?: ExtrapolateType,\n};\n\nvar linear = (t) => t;\n\n/**\n * Very handy helper to map input ranges to output ranges with an easing\n * function and custom behavior outside of the ranges.\n */\nclass Interpolation {\n  static create(config: InterpolationConfigType): (input: number) => number | string {\n\n    if (config.outputRange && typeof config.outputRange[0] === 'string') {\n      return createInterpolationFromStringOutputRange(config);\n    }\n\n    var outputRange: Array<number> = (config.outputRange: any);\n    checkInfiniteRange('outputRange', outputRange);\n\n    var inputRange = config.inputRange;\n    checkInfiniteRange('inputRange', inputRange);\n    checkValidInputRange(inputRange);\n\n    invariant(\n      inputRange.length === outputRange.length,\n      'inputRange (' + inputRange.length + ') and outputRange (' +\n      outputRange.length + ') must have the same length'\n    );\n\n    var easing = config.easing || linear;\n\n    var extrapolateLeft: ExtrapolateType = 'extend';\n    if (config.extrapolateLeft !== undefined) {\n      extrapolateLeft = config.extrapolateLeft;\n    } else if (config.extrapolate !== undefined) {\n      extrapolateLeft = config.extrapolate;\n    }\n\n    var extrapolateRight: ExtrapolateType = 'extend';\n    if (config.extrapolateRight !== undefined) {\n      extrapolateRight = config.extrapolateRight;\n    } else if (config.extrapolate !== undefined) {\n      extrapolateRight = config.extrapolate;\n    }\n\n    return (input) => {\n      invariant(\n        typeof input === 'number',\n        'Cannot interpolation an input which is not a number'\n      );\n\n      var range = findRange(input, inputRange);\n      return interpolate(\n        input,\n        inputRange[range],\n        inputRange[range + 1],\n        outputRange[range],\n        outputRange[range + 1],\n        easing,\n        extrapolateLeft,\n        extrapolateRight,\n      );\n    };\n  }\n}\n\nfunction interpolate(\n  input: number,\n  inputMin: number,\n  inputMax: number,\n  outputMin: number,\n  outputMax: number,\n  easing: ((input: number) => number),\n  extrapolateLeft: ExtrapolateType,\n  extrapolateRight: ExtrapolateType,\n) {\n  var result = input;\n\n  // Extrapolate\n  if (result < inputMin) {\n    if (extrapolateLeft === 'identity') {\n      return result;\n    } else if (extrapolateLeft === 'clamp') {\n      result = inputMin;\n    } else if (extrapolateLeft === 'extend') {\n      // noop\n    }\n  }\n\n  if (result > inputMax) {\n    if (extrapolateRight === 'identity') {\n      return result;\n    } else if (extrapolateRight === 'clamp') {\n      result = inputMax;\n    } else if (extrapolateRight === 'extend') {\n      // noop\n    }\n  }\n\n  if (outputMin === outputMax) {\n    return outputMin;\n  }\n\n  if (inputMin === inputMax) {\n    if (input <= inputMin) {\n      return outputMin;\n    }\n    return outputMax;\n  }\n\n  // Input Range\n  if (inputMin === -Infinity) {\n    result = -result;\n  } else if (inputMax === Infinity) {\n    result = result - inputMin;\n  } else {\n    result = (result - inputMin) / (inputMax - inputMin);\n  }\n\n  // Easing\n  result = easing(result);\n\n  // Output Range\n  if (outputMin === -Infinity) {\n    result = -result;\n  } else if (outputMax === Infinity) {\n    result = result + outputMin;\n  } else {\n    result = result * (outputMax - outputMin) + outputMin;\n  }\n\n  return result;\n}\n\nfunction colorToRgba(input: string): string {\n  var int32Color = normalizeColor(input);\n  if (int32Color === null) {\n    return input;\n  }\n\n  int32Color = int32Color || 0;\n\n  var r = (int32Color & 0xff000000) >>> 24;\n  var g = (int32Color & 0x00ff0000) >>> 16;\n  var b = (int32Color & 0x0000ff00) >>> 8;\n  var a = (int32Color & 0x000000ff) / 255;\n\n  return `rgba(${r}, ${g}, ${b}, ${a})`;\n}\n\nvar stringShapeRegex = /[0-9\\.-]+/g;\n\n/**\n * Supports string shapes by extracting numbers so new values can be computed,\n * and recombines those values into new strings of the same shape.  Supports\n * things like:\n *\n *   rgba(123, 42, 99, 0.36) // colors\n *   -45deg                  // values with units\n */\nfunction createInterpolationFromStringOutputRange(\n  config: InterpolationConfigType,\n): (input: number) => string {\n  var outputRange: Array<string> = (config.outputRange: any);\n  invariant(outputRange.length >= 2, 'Bad output range');\n  outputRange = outputRange.map(colorToRgba);\n  checkPattern(outputRange);\n\n  // ['rgba(0, 100, 200, 0)', 'rgba(50, 150, 250, 0.5)']\n  // ->\n  // [\n  //   [0, 50],\n  //   [100, 150],\n  //   [200, 250],\n  //   [0, 0.5],\n  // ]\n  /* $FlowFixMe(>=0.18.0): `outputRange[0].match()` can return `null`. Need to\n   * guard against this possibility.\n   */\n  var outputRanges = outputRange[0].match(stringShapeRegex).map(() => []);\n  outputRange.forEach(value => {\n    /* $FlowFixMe(>=0.18.0): `value.match()` can return `null`. Need to guard\n     * against this possibility.\n     */\n    value.match(stringShapeRegex).forEach((number, i) => {\n      outputRanges[i].push(+number);\n    });\n  });\n\n  /* $FlowFixMe(>=0.18.0): `outputRange[0].match()` can return `null`. Need to\n   * guard against this possibility.\n   */\n  var interpolations = outputRange[0].match(stringShapeRegex).map((value, i) => {\n    return Interpolation.create({\n      ...config,\n      outputRange: outputRanges[i],\n    });\n  });\n\n  // rgba requires that the r,g,b are integers.... so we want to round them, but we *dont* want to\n  // round the opacity (4th column).\n  const shouldRound = isRgbOrRgba(outputRange[0]);\n\n  return (input) => {\n    var i = 0;\n    // 'rgba(0, 100, 200, 0)'\n    // ->\n    // 'rgba(${interpolations[0](input)}, ${interpolations[1](input)}, ...'\n    return outputRange[0].replace(stringShapeRegex, () => {\n      const val = +interpolations[i++](input);\n      const rounded = shouldRound && i < 4 ? Math.round(val) : Math.round(val * 1000) / 1000;\n      return String(rounded);\n    });\n  };\n}\n\nfunction isRgbOrRgba(range) {\n  return typeof range === 'string' && range.startsWith('rgb');\n}\n\nfunction checkPattern(arr: Array<string>) {\n  var pattern = arr[0].replace(stringShapeRegex, '');\n  for (var i = 1; i < arr.length; ++i) {\n    invariant(\n      pattern === arr[i].replace(stringShapeRegex, ''),\n      'invalid pattern ' + arr[0] + ' and ' + arr[i],\n    );\n  }\n}\n\nfunction findRange(input: number, inputRange: Array<number>) {\n  for (var i = 1; i < inputRange.length - 1; ++i) {\n    if (inputRange[i] >= input) {\n      break;\n    }\n  }\n  return i - 1;\n}\n\nfunction checkValidInputRange(arr: Array<number>) {\n  invariant(arr.length >= 2, 'inputRange must have at least 2 elements');\n  for (var i = 1; i < arr.length; ++i) {\n    invariant(\n      arr[i] >= arr[i - 1],\n      /* $FlowFixMe(>=0.13.0) - In the addition expression below this comment,\n       * one or both of the operands may be something that doesn't cleanly\n       * convert to a string, like undefined, null, and object, etc. If you really\n       * mean this implicit string conversion, you can do something like\n       * String(myThing)\n       */\n      'inputRange must be monotonically increasing ' + arr\n    );\n  }\n}\n\nfunction checkInfiniteRange(name: string, arr: Array<number>) {\n  invariant(arr.length >= 2, name + ' must have at least 2 elements');\n  invariant(\n    arr.length !== 2 || arr[0] !== -Infinity || arr[1] !== Infinity,\n    /* $FlowFixMe(>=0.13.0) - In the addition expression below this comment,\n     * one or both of the operands may be something that doesn't cleanly convert\n     * to a string, like undefined, null, and object, etc. If you really mean\n     * this implicit string conversion, you can do something like\n     * String(myThing)\n     */\n    name + 'cannot be ]-infinity;+infinity[ ' + arr\n  );\n}\n\nmodule.exports = Interpolation;\n"]}