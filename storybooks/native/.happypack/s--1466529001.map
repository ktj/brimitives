{"version":3,"sources":["node_modules/react-native/Libraries/Core/Timers/JSTimers.js"],"names":["Platform","require","Systrace","invariant","Timing","_performanceNow","performanceNow","FRAME_DURATION","IDLE_CALLBACK_FRAME_DEADLINE","MAX_TIMER_DURATION_MS","IS_ANDROID","OS","ANDROID_LONG_TIMER_MESSAGE","callbacks","types","timerIDs","immediates","requestIdleCallbacks","requestIdleCallbackTimeouts","identifiers","GUID","errors","hasEmittedTimeDriftWarning","_getFreeIndex","freeIndex","indexOf","length","_allocateCallback","func","type","id","__DEV__","parseErrorStack","error","Error","framesToPop","stack","shift","_callTimer","timerID","frameTime","didTimeout","timerIndex","callback","console","identifier","beginEvent","methodName","_clearIndex","timeRemaining","Math","max","e","push","endEvent","_callImmediatesPass","passImmediates","slice","i","_freeCallback","index","deleteTimer","JSTimers","setTimeout","duration","args","warn","apply","undefined","createTimer","Date","now","setInterval","setImmediate","requestAnimationFrame","requestIdleCallback","options","setSendIdleEvents","timeout","timeoutId","clearTimeout","deadline","splice","cancelIdleCallback","clearInterval","clearImmediate","cancelAnimationFrame","callTimers","timersToCall","errorCount","ii","bind","callIdleCallbacks","passIdleCallbacks","forEach","callImmediates","emitTimeDriftWarning","warningMessage","module","exports"],"mappings":";;;;;;;;;;;;AAYA;;AAEA,GAAMA,UAAWC,QAAQ,UAAR,CAAjB;AACA,GAAMC,UAAWD,QAAQ,UAAR,CAAjB;;AAEA,GAAME,WAAYF,QAAQ,oBAAR,CAAlB,C;AACiBA,QAAQ,eAAR,C,CAAVG,M,UAAAA,M;;;;AAIP,GAAIC,iBAAkB,IAAtB;AACA,QAASC,eAAT,EAA0B;AACxB,GAAI,CAACD,eAAL,CAAsB;AACpBA,gBAAkBJ,QAAQ,yBAAR,CAAlB;AACD;AACD,MAAOI,kBAAP;AACD;;;;;;;;;;;;;;;;;AAiBD,GAAME,gBAAiB,KAAO,EAA9B;AACA,GAAMC,8BAA+B,CAArC;;AAEA,GAAMC,uBAAwB,GAAK,IAAnC;AACA,GAAMC,YAAaV,SAASW,EAAT,GAAgB,SAAnC;AACA,GAAMC;AACJ;AACA,qEADA;AAEA,iFAFA;AAGA,0EAJF;;;AAOA,GAAMC,WAA8B,EAApC;AACA,GAAMC,OAA6B,EAAnC;AACA,GAAMC,UAA2B,EAAjC;AACA,GAAIC,YAA4B,EAAhC;AACA,GAAIC,sBAAsC,EAA1C;AACA,GAAMC,6BAAkD,EAAxD;AACA,GAAMC,aAAkD,EAAxD;;AAEA,GAAIC,MAAO,CAAX;AACA,GAAIC,QAAwB,IAA5B;;AAEA,GAAIC,4BAA6B,KAAjC;;;AAGA,QAASC,cAAT,EAAiC;AAC/B,GAAIC,WAAYT,SAASU,OAAT,CAAiB,IAAjB,CAAhB;AACA,GAAID,YAAc,CAAC,CAAnB,CAAsB;AACpBA,UAAYT,SAASW,MAArB;AACD;AACD,MAAOF,UAAP;AACD;;AAED,QAASG,kBAAT,CAA2BC,IAA3B,CAA2CC,IAA3C,CAAsE;AACpE,GAAMC,IAAKV,MAAX;AACA,GAAMI,WAAYD,eAAlB;AACAR,SAASS,SAAT,EAAsBM,EAAtB;AACAjB,UAAUW,SAAV,EAAuBI,IAAvB;AACAd,MAAMU,SAAN,EAAmBK,IAAnB;AACA,GAAIE,OAAJ,CAAa;AACX,GAAMC,iBAAkB/B,QAAQ,iBAAR,CAAxB;AACA,GAAMgC,OAAuB,GAAIC,MAAJ,EAA7B;AACAD,MAAME,WAAN,CAAoB,CAApB;AACA,GAAMC,OAAQJ,gBAAgBC,KAAhB,CAAd;AACA,GAAIG,KAAJ,CAAW;AACTjB,YAAYK,SAAZ,EAAyBY,MAAMC,KAAN,EAAzB;AACD;AACF;AACD,MAAOP,GAAP;AACD;;;;;;;AAOD,QAASQ,WAAT,CAAoBC,OAApB,CAAqCC,SAArC,CAAwDC,UAAxD,CAA8E;AAC5ExC,QAAQ,kBAAR;AACEsC,SAAWnB,IADb;AAEE,0DAFF;AAGEmB,OAHF;;;;;;;;AAWA,GAAMG,YAAa3B,SAASU,OAAT,CAAiBc,OAAjB,CAAnB;AACA,GAAIG,aAAe,CAAC,CAApB,CAAuB;AACrB;AACD;;AAED,GAAMb,MAAOf,MAAM4B,UAAN,CAAb;AACA,GAAMC,UAAW9B,UAAU6B,UAAV,CAAjB;AACA,GAAI,CAACC,QAAD,EAAa,CAACd,IAAlB,CAAwB;AACtBe,QAAQX,KAAR,CAAc,iCAAmCM,OAAjD;AACA;AACD;;AAED,GAAIR,OAAJ,CAAa;AACX,GAAMc,YAAa1B,YAAYuB,UAAZ,GAA2B,EAA9C;AACAxC,SAAS4C,UAAT,CAAoB,uBAAyBD,WAAWE,UAAxD;AACD;;;AAGD;AACElB,OAAS,YAAT;AACAA,OAAS,cADT;AAEAA,OAAS,uBAFT;AAGAA,OAAS,qBAJX;AAKE;AACAmB,YAAYN,UAAZ;AACD;;AAED,GAAI;AACF;AACEb,OAAS,YAAT;AACAA,OAAS,aADT;AAEAA,OAAS,cAHX;AAIE;AACAc;AACD,CAND,IAMO,IAAId,OAAS,uBAAb,CAAsC;AAC3Cc,SAASrC,gBAAT;AACD,CAFM,IAEA,IAAIuB,OAAS,qBAAb,CAAoC;AACzCc,SAAS;AACPM,cAAe,wBAAW;;;;AAIxB,MAAOC,MAAKC,GAAL,CAAS,CAAT,CAAY5C,gBAAkBD,iBAAmBkC,SAArC,CAAZ,CAAP;AACD,CANM;AAOPC,WAAY,CAAC,CAACA,UAPP,CAAT;;AASD,CAVM,IAUA;AACLG,QAAQX,KAAR,CAAc,+CAAiDJ,IAA/D;AACD;AACF,CAAC,MAAOuB,CAAP,CAAU;;AAEV,GAAI,CAAC/B,MAAL,CAAa;AACXA,OAAS,CAAC+B,CAAD,CAAT;AACD,CAFD,IAEO;AACL/B,OAAOgC,IAAP,CAAYD,CAAZ;AACD;AACF;;AAED,GAAIrB,OAAJ,CAAa;AACX7B,SAASoD,QAAT;AACD;AACF;;;;;;AAMD,QAASC,oBAAT,EAA+B;AAC7B,GAAIxB,OAAJ,CAAa;AACX7B,SAAS4C,UAAT,CAAoB,sBAApB;AACD;;;;AAID,GAAI9B,WAAWU,MAAX,CAAoB,CAAxB,CAA2B;AACzB,GAAM8B,gBAAiBxC,WAAWyC,KAAX,EAAvB;AACAzC,WAAa,EAAb;;;;AAIA,IAAK,GAAI0C,GAAI,CAAb,CAAgBA,EAAIF,eAAe9B,MAAnC,CAA2C,EAAEgC,CAA7C,CAAgD;AAC9CpB,WAAWkB,eAAeE,CAAf,CAAX,CAA8B,CAA9B;AACD;AACF;;AAED,GAAI3B,OAAJ,CAAa;AACX7B,SAASoD,QAAT;AACD;AACD,MAAOtC,YAAWU,MAAX,CAAoB,CAA3B;AACD;;AAED,QAASsB,YAAT,CAAqBU,CAArB,CAAgC;AAC9B3C,SAAS2C,CAAT,EAAc,IAAd;AACA7C,UAAU6C,CAAV,EAAe,IAAf;AACA5C,MAAM4C,CAAN,EAAW,IAAX;AACAvC,YAAYuC,CAAZ,EAAiB,IAAjB;AACD;;AAED,QAASC,cAAT,CAAuBpB,OAAvB,CAAwC;;;AAGtC,GAAIA,SAAW,IAAf,CAAqB;AACnB;AACD;;AAED,GAAMqB,OAAQ7C,SAASU,OAAT,CAAiBc,OAAjB,CAAd;;AAEA,GAAIqB,QAAU,CAAC,CAAf,CAAkB;AAChBZ,YAAYY,KAAZ;AACA,GAAM/B,MAAOf,MAAM8C,KAAN,CAAb;AACA,GAAI/B,OAAS,cAAT,EAA2BA,OAAS,qBAAxC,CAA+D;AAC7DzB,OAAOyD,WAAP,CAAmBtB,OAAnB;AACD;AACF;AACF;;;;;;;AAOD,GAAMuB,UAAW;;;;;AAKfC,WAAY;AACVnC,IADU;AAEVoC,QAFU;;AAIF,+BADLC,IACK,iDADLA,IACK;AACR,GAAIlC,SAAWrB,UAAX,EAAyBsD,SAAWvD,qBAAxC,CAA+D;AAC7DmC,QAAQsB,IAAR;AACEtD;AACE,IADF;AAEE,gCAFF;AAGEoD,QAHF;AAIE,KALJ;;AAOD;AACD,GAAMlC,IAAKH;AACT,iBAAMC,MAAKuC,KAAL,CAAWC,SAAX,CAAsBH,IAAtB,CAAN,EADS;AAET,YAFS,CAAX;;AAIA7D,OAAOiE,WAAP,CAAmBvC,EAAnB,CAAuBkC,UAAY,CAAnC,CAAsCM,KAAKC,GAAL,EAAtC,CAAkE,KAAlE;AACA,MAAOzC,GAAP;AACD,CAzBc;;;;;;AA+Bf0C,YAAa;AACX5C,IADW;AAEXoC,QAFW;;AAIH,gCADLC,IACK,uDADLA,IACK;AACR,GAAIlC,SAAWrB,UAAX,EAAyBsD,SAAWvD,qBAAxC,CAA+D;AAC7DmC,QAAQsB,IAAR;AACEtD;AACE,IADF;AAEE,iCAFF;AAGEoD,QAHF;AAIE,KALJ;;AAOD;AACD,GAAMlC,IAAKH;AACT,iBAAMC,MAAKuC,KAAL,CAAWC,SAAX,CAAsBH,IAAtB,CAAN,EADS;AAET,aAFS,CAAX;;AAIA7D,OAAOiE,WAAP,CAAmBvC,EAAnB,CAAuBkC,UAAY,CAAnC,CAAsCM,KAAKC,GAAL,EAAtC,CAAkE,IAAlE;AACA,MAAOzC,GAAP;AACD,CAnDc;;;;;;AAyDf2C,aAAc,sBAAS7C,IAAT,CAAwC,gCAAZqC,IAAY,uDAAZA,IAAY;AACpD,GAAMnC,IAAKH;AACT,iBAAMC,MAAKuC,KAAL,CAAWC,SAAX,CAAsBH,IAAtB,CAAN,EADS;AAET,cAFS,CAAX;;AAIAjD,WAAWqC,IAAX,CAAgBvB,EAAhB;AACA,MAAOA,GAAP;AACD,CAhEc;;;;;AAqEf4C,sBAAuB,+BAAS9C,IAAT,CAAyB;AAC9C,GAAME,IAAKH,kBAAkBC,IAAlB,CAAwB,uBAAxB,CAAX;AACAxB,OAAOiE,WAAP,CAAmBvC,EAAnB,CAAuB,CAAvB,CAA0BwC,KAAKC,GAAL,EAA1B,CAAsD,KAAtD;AACA,MAAOzC,GAAP;AACD,CAzEc;;;;;;;AAgFf6C,oBAAqB,6BAAS/C,IAAT,CAAyBgD,OAAzB,CAA2C;AAC9D,GAAI3D,qBAAqBS,MAArB,GAAgC,CAApC,CAAuC;AACrCtB,OAAOyE,iBAAP,CAAyB,IAAzB;AACD;;AAED,GAAMC,SAAUF,SAAWA,QAAQE,OAAnC;AACA,GAAMhD,IAAKH;AACTmD,SAAW,IAAX;AACI,kBAAY;AACV,GAAMC,WAAY7D,4BAA4BY,EAA5B,CAAlB;AACA,GAAIiD,SAAJ,CAAe;AACbjB,SAASkB,YAAT,CAAsBD,SAAtB;AACA7D,4BAA4BY,EAA5B;AACD;AACD,MAAOF,MAAKqD,QAAL,CAAP;AACD,CARL;AASIrD,IAVK;AAWT,qBAXS,CAAX;;AAaAX,qBAAqBoC,IAArB,CAA0BvB,EAA1B;;AAEA,GAAIgD,SAAW,IAAf,CAAqB;AACnB,GAAMC,WAAYjB,SAASC,UAAT,CAAoB,UAAM;AAC1C,GAAMH,OAAQ3C,qBAAqBQ,OAArB,CAA6BK,EAA7B,CAAd;AACA,GAAI8B,MAAQ,CAAC,CAAb,CAAgB;AACd3C,qBAAqBiE,MAArB,CAA4BtB,KAA5B,CAAmC,CAAnC;AACAtB,WAAWR,EAAX,CAAexB,gBAAf,CAAiC,IAAjC;AACD;AACD,MAAOY,6BAA4BY,EAA5B,CAAP;AACA,GAAIb,qBAAqBS,MAArB,GAAgC,CAApC,CAAuC;AACrCtB,OAAOyE,iBAAP,CAAyB,KAAzB;AACD;AACF,CAViB,CAUfC,OAVe,CAAlB;AAWA5D,4BAA4BY,EAA5B,EAAkCiD,SAAlC;AACD;AACD,MAAOjD,GAAP;AACD,CApHc;;AAsHfqD,mBAAoB,4BAAS5C,OAAT,CAA0B;AAC5CoB,cAAcpB,OAAd;AACA,GAAMqB,OAAQ3C,qBAAqBQ,OAArB,CAA6Bc,OAA7B,CAAd;AACA,GAAIqB,QAAU,CAAC,CAAf,CAAkB;AAChB3C,qBAAqBiE,MAArB,CAA4BtB,KAA5B,CAAmC,CAAnC;AACD;;AAED,GAAMmB,WAAY7D,4BAA4BqB,OAA5B,CAAlB;AACA,GAAIwC,SAAJ,CAAe;AACbjB,SAASkB,YAAT,CAAsBD,SAAtB;AACA,MAAO7D,6BAA4BqB,OAA5B,CAAP;AACD;;AAED,GAAItB,qBAAqBS,MAArB,GAAgC,CAApC,CAAuC;AACrCtB,OAAOyE,iBAAP,CAAyB,KAAzB;AACD;AACF,CAtIc;;AAwIfG,aAAc,sBAASzC,OAAT,CAA0B;AACtCoB,cAAcpB,OAAd;AACD,CA1Ic;;AA4If6C,cAAe,uBAAS7C,OAAT,CAA0B;AACvCoB,cAAcpB,OAAd;AACD,CA9Ic;;AAgJf8C,eAAgB,wBAAS9C,OAAT,CAA0B;AACxCoB,cAAcpB,OAAd;AACA,GAAMqB,OAAQ5C,WAAWS,OAAX,CAAmBc,OAAnB,CAAd;AACA,GAAIqB,QAAU,CAAC,CAAf,CAAkB;AAChB5C,WAAWkE,MAAX,CAAkBtB,KAAlB,CAAyB,CAAzB;AACD;AACF,CAtJc;;AAwJf0B,qBAAsB,8BAAS/C,OAAT,CAA0B;AAC9CoB,cAAcpB,OAAd;AACD,CA1Jc;;;;;;AAgKfgD,WAAY,oBAASC,YAAT,CAAsC;AAChDrF;AACEqF,aAAa9D,MAAb,GAAwB,CAD1B;AAEE,qDAFF;;;;AAMAL,OAAS,IAAT;AACA,IAAK,GAAIqC,GAAI,CAAb,CAAgBA,EAAI8B,aAAa9D,MAAjC,CAAyCgC,GAAzC,CAA8C;AAC5CpB,WAAWkD,aAAa9B,CAAb,CAAX,CAA4B,CAA5B;AACD;;AAED,GAAIrC,MAAJ,CAAY;AACV,GAAMoE,YAAapE,OAAOK,MAA1B;AACA,GAAI+D,WAAa,CAAjB,CAAoB;;;AAGlB,IAAK,GAAIC,IAAK,CAAd,CAAiBA,GAAKD,UAAtB,CAAkCC,IAAlC,CAAwC;AACtC5B,SAASC,UAAT;AACG,eAAS;AACR,KAAM9B,MAAN;AACD,CAFD,CAEG0D,IAFH,CAEQ,IAFR,CAEctE,OAAOqE,EAAP,CAFd,CADF;AAIE,CAJF;;AAMD;AACF;AACD,KAAMrE,QAAO,CAAP,CAAN;AACD;AACF,CA5Lc;;AA8LfuE,kBAAmB,2BAASpD,SAAT,CAA4B;AAC7C;AACEjC,gBAAkBD,iBAAmBkC,SAArC;AACAhC,4BAFF;AAGE;AACA;AACD;;;AAGDa,OAAS,IAAT;AACA,GAAIJ,qBAAqBS,MAArB,CAA8B,CAAlC,CAAqC;AACnC,GAAMmE,mBAAoB5E,qBAAqBwC,KAArB,EAA1B;AACAxC,qBAAuB,EAAvB;;AAEA,IAAK,GAAIyC,GAAI,CAAb,CAAgBA,EAAImC,kBAAkBnE,MAAtC,CAA8C,EAAEgC,CAAhD,CAAmD;AACjDpB,WAAWuD,kBAAkBnC,CAAlB,CAAX,CAAiClB,SAAjC;AACD;AACF;;AAED,GAAIvB,qBAAqBS,MAArB,GAAgC,CAApC,CAAuC;AACrCtB,OAAOyE,iBAAP,CAAyB,KAAzB;AACD;;AAED,GAAIxD,MAAJ,CAAY;AACVA,OAAOyE,OAAP,CAAe;AACbhC,SAASC,UAAT,CAAoB,UAAM;AACxB,KAAM9B,MAAN;AACD,CAFD,CAEG,CAFH,CADa,GAAf;;AAKD;AACF,CA5Nc;;;;;;AAkOf8D,cAlOe,0BAkOE;AACf1E,OAAS,IAAT;AACA,MAAOkC,qBAAP,CAA8B,CAAE;AAChC,GAAIlC,MAAJ,CAAY;AACVA,OAAOyE,OAAP,CAAe;AACbhC,SAASC,UAAT,CAAoB,UAAM;AACxB,KAAM9B,MAAN;AACD,CAFD,CAEG,CAFH,CADa,GAAf;;AAKD;AACF,CA5Oc;;;;;AAiPf+D,oBAjPe,+BAiPMC,cAjPN,CAiP8B;AAC3C,GAAI3E,0BAAJ,CAAgC;AAC9B;AACD;AACDA,2BAA6B,IAA7B;AACAsB,QAAQsB,IAAR,CAAa+B,cAAb;AACD,CAvPc,CAAjB;;;AA0PA,GAAI,CAAC7F,MAAL,CAAa;AACXwC,QAAQsB,IAAR,CAAa,0DAAb;;AAEAgC,OAAOC,OAAP,CAAkB;AAChBJ,eAAgBjC,SAASiC,cADT;AAEhBtB,aAAcX,SAASW,YAFP,CAAlB;;AAID,CAPD,IAOO;AACLyB,OAAOC,OAAP,CAAiBrC,QAAjB;AACD,C,0GAxdGzD,e,iKACKC,c,gKAsBHC,c,gKACAC,4B,8KAEAC,qB,uKACAC,U,4JACAE,0B,4KAOAC,S,2JACAC,K,uJACAC,Q,0JACFC,U,4JACAC,oB,sKACEC,2B,6KACAC,W,6JAEFC,I,sJACAC,M,wJAEAC,0B,4KAGKC,a,+JAQAI,iB,mKAuBAW,U,4JA+EAiB,mB,qKAwBAP,W,6JAOAW,a,+JAuBHG,Q","file":"JSTimers.js","sourceRoot":"/home/phz/workspace/brimitives/storybooks/native","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule JSTimers\n * @format\n * @flow\n */\n'use strict';\n\nconst Platform = require('Platform');\nconst Systrace = require('Systrace');\n\nconst invariant = require('fbjs/lib/invariant');\nconst {Timing} = require('NativeModules');\n\nimport type {ExtendedError} from 'parseErrorStack';\n\nlet _performanceNow = null;\nfunction performanceNow() {\n  if (!_performanceNow) {\n    _performanceNow = require('fbjs/lib/performanceNow');\n  }\n  return _performanceNow();\n}\n\n/**\n * JS implementation of timer functions. Must be completely driven by an\n * external clock signal, all that's stored here is timerID, timer type, and\n * callback.\n */\n\nexport type JSTimerType =\n  | 'setTimeout'\n  | 'setInterval'\n  | 'requestAnimationFrame'\n  | 'setImmediate'\n  | 'requestIdleCallback';\n\n// These timing contants should be kept in sync with the ones in native ios and\n// android `RCTTiming` module.\nconst FRAME_DURATION = 1000 / 60;\nconst IDLE_CALLBACK_FRAME_DEADLINE = 1;\n\nconst MAX_TIMER_DURATION_MS = 60 * 1000;\nconst IS_ANDROID = Platform.OS === 'android';\nconst ANDROID_LONG_TIMER_MESSAGE =\n  'Setting a timer for a long period of time, i.e. multiple minutes, is a ' +\n  'performance and correctness issue on Android as it keeps the timer ' +\n  'module awake, and timers can only be called when the app is in the foreground. ' +\n  'See https://github.com/facebook/react-native/issues/12981 for more info.';\n\n// Parallel arrays\nconst callbacks: Array<?Function> = [];\nconst types: Array<?JSTimerType> = [];\nconst timerIDs: Array<?number> = [];\nlet immediates: Array<number> = [];\nlet requestIdleCallbacks: Array<number> = [];\nconst requestIdleCallbackTimeouts: {[number]: number} = {};\nconst identifiers: Array<null | {methodName: string}> = [];\n\nlet GUID = 1;\nlet errors: ?Array<Error> = null;\n\nlet hasEmittedTimeDriftWarning = false;\n\n// Returns a free index if one is available, and the next consecutive index otherwise.\nfunction _getFreeIndex(): number {\n  let freeIndex = timerIDs.indexOf(null);\n  if (freeIndex === -1) {\n    freeIndex = timerIDs.length;\n  }\n  return freeIndex;\n}\n\nfunction _allocateCallback(func: Function, type: JSTimerType): number {\n  const id = GUID++;\n  const freeIndex = _getFreeIndex();\n  timerIDs[freeIndex] = id;\n  callbacks[freeIndex] = func;\n  types[freeIndex] = type;\n  if (__DEV__) {\n    const parseErrorStack = require('parseErrorStack');\n    const error: ExtendedError = new Error();\n    error.framesToPop = 1;\n    const stack = parseErrorStack(error);\n    if (stack) {\n      identifiers[freeIndex] = stack.shift();\n    }\n  }\n  return id;\n}\n\n/**\n * Calls the callback associated with the ID. Also unregister that callback\n * if it was a one time timer (setTimeout), and not unregister it if it was\n * recurring (setInterval).\n */\nfunction _callTimer(timerID: number, frameTime: number, didTimeout: ?boolean) {\n  require('fbjs/lib/warning')(\n    timerID <= GUID,\n    'Tried to call timer with ID %s but no such timer exists.',\n    timerID,\n  );\n\n  // timerIndex of -1 means that no timer with that ID exists. There are\n  // two situations when this happens, when a garbage timer ID was given\n  // and when a previously existing timer was deleted before this callback\n  // fired. In both cases we want to ignore the timer id, but in the former\n  // case we warn as well.\n  const timerIndex = timerIDs.indexOf(timerID);\n  if (timerIndex === -1) {\n    return;\n  }\n\n  const type = types[timerIndex];\n  const callback = callbacks[timerIndex];\n  if (!callback || !type) {\n    console.error('No callback found for timerID ' + timerID);\n    return;\n  }\n\n  if (__DEV__) {\n    const identifier = identifiers[timerIndex] || {};\n    Systrace.beginEvent('Systrace.callTimer: ' + identifier.methodName);\n  }\n\n  // Clear the metadata\n  if (\n    type === 'setTimeout' ||\n    type === 'setImmediate' ||\n    type === 'requestAnimationFrame' ||\n    type === 'requestIdleCallback'\n  ) {\n    _clearIndex(timerIndex);\n  }\n\n  try {\n    if (\n      type === 'setTimeout' ||\n      type === 'setInterval' ||\n      type === 'setImmediate'\n    ) {\n      callback();\n    } else if (type === 'requestAnimationFrame') {\n      callback(performanceNow());\n    } else if (type === 'requestIdleCallback') {\n      callback({\n        timeRemaining: function() {\n          // TODO: Optimisation: allow running for longer than one frame if\n          // there are no pending JS calls on the bridge from native. This\n          // would require a way to check the bridge queue synchronously.\n          return Math.max(0, FRAME_DURATION - (performanceNow() - frameTime));\n        },\n        didTimeout: !!didTimeout,\n      });\n    } else {\n      console.error('Tried to call a callback with invalid type: ' + type);\n    }\n  } catch (e) {\n    // Don't rethrow so that we can run all timers.\n    if (!errors) {\n      errors = [e];\n    } else {\n      errors.push(e);\n    }\n  }\n\n  if (__DEV__) {\n    Systrace.endEvent();\n  }\n}\n\n/**\n * Performs a single pass over the enqueued immediates. Returns whether\n * more immediates are queued up (can be used as a condition a while loop).\n */\nfunction _callImmediatesPass() {\n  if (__DEV__) {\n    Systrace.beginEvent('callImmediatesPass()');\n  }\n\n  // The main reason to extract a single pass is so that we can track\n  // in the system trace\n  if (immediates.length > 0) {\n    const passImmediates = immediates.slice();\n    immediates = [];\n\n    // Use for loop rather than forEach as per @vjeux's advice\n    // https://github.com/facebook/react-native/commit/c8fd9f7588ad02d2293cac7224715f4af7b0f352#commitcomment-14570051\n    for (let i = 0; i < passImmediates.length; ++i) {\n      _callTimer(passImmediates[i], 0);\n    }\n  }\n\n  if (__DEV__) {\n    Systrace.endEvent();\n  }\n  return immediates.length > 0;\n}\n\nfunction _clearIndex(i: number) {\n  timerIDs[i] = null;\n  callbacks[i] = null;\n  types[i] = null;\n  identifiers[i] = null;\n}\n\nfunction _freeCallback(timerID: number) {\n  // timerIDs contains nulls after timers have been removed;\n  // ignore nulls upfront so indexOf doesn't find them\n  if (timerID == null) {\n    return;\n  }\n\n  const index = timerIDs.indexOf(timerID);\n  // See corresponding comment in `callTimers` for reasoning behind this\n  if (index !== -1) {\n    _clearIndex(index);\n    const type = types[index];\n    if (type !== 'setImmediate' && type !== 'requestIdleCallback') {\n      Timing.deleteTimer(timerID);\n    }\n  }\n}\n\n/**\n * JS implementation of timer functions. Must be completely driven by an\n * external clock signal, all that's stored here is timerID, timer type, and\n * callback.\n */\nconst JSTimers = {\n  /**\n   * @param {function} func Callback to be invoked after `duration` ms.\n   * @param {number} duration Number of milliseconds.\n   */\n  setTimeout: function(\n    func: Function,\n    duration: number,\n    ...args?: any\n  ): number {\n    if (__DEV__ && IS_ANDROID && duration > MAX_TIMER_DURATION_MS) {\n      console.warn(\n        ANDROID_LONG_TIMER_MESSAGE +\n          '\\n' +\n          '(Saw setTimeout with duration ' +\n          duration +\n          'ms)',\n      );\n    }\n    const id = _allocateCallback(\n      () => func.apply(undefined, args),\n      'setTimeout',\n    );\n    Timing.createTimer(id, duration || 0, Date.now(), /* recurring */ false);\n    return id;\n  },\n\n  /**\n   * @param {function} func Callback to be invoked every `duration` ms.\n   * @param {number} duration Number of milliseconds.\n   */\n  setInterval: function(\n    func: Function,\n    duration: number,\n    ...args?: any\n  ): number {\n    if (__DEV__ && IS_ANDROID && duration > MAX_TIMER_DURATION_MS) {\n      console.warn(\n        ANDROID_LONG_TIMER_MESSAGE +\n          '\\n' +\n          '(Saw setInterval with duration ' +\n          duration +\n          'ms)',\n      );\n    }\n    const id = _allocateCallback(\n      () => func.apply(undefined, args),\n      'setInterval',\n    );\n    Timing.createTimer(id, duration || 0, Date.now(), /* recurring */ true);\n    return id;\n  },\n\n  /**\n   * @param {function} func Callback to be invoked before the end of the\n   * current JavaScript execution loop.\n   */\n  setImmediate: function(func: Function, ...args?: any) {\n    const id = _allocateCallback(\n      () => func.apply(undefined, args),\n      'setImmediate',\n    );\n    immediates.push(id);\n    return id;\n  },\n\n  /**\n   * @param {function} func Callback to be invoked every frame.\n   */\n  requestAnimationFrame: function(func: Function) {\n    const id = _allocateCallback(func, 'requestAnimationFrame');\n    Timing.createTimer(id, 1, Date.now(), /* recurring */ false);\n    return id;\n  },\n\n  /**\n   * @param {function} func Callback to be invoked every frame and provided\n   * with time remaining in frame.\n   * @param {?object} options\n   */\n  requestIdleCallback: function(func: Function, options: ?Object) {\n    if (requestIdleCallbacks.length === 0) {\n      Timing.setSendIdleEvents(true);\n    }\n\n    const timeout = options && options.timeout;\n    const id = _allocateCallback(\n      timeout != null\n        ? deadline => {\n            const timeoutId = requestIdleCallbackTimeouts[id];\n            if (timeoutId) {\n              JSTimers.clearTimeout(timeoutId);\n              requestIdleCallbackTimeouts[id];\n            }\n            return func(deadline);\n          }\n        : func,\n      'requestIdleCallback',\n    );\n    requestIdleCallbacks.push(id);\n\n    if (timeout != null) {\n      const timeoutId = JSTimers.setTimeout(() => {\n        const index = requestIdleCallbacks.indexOf(id);\n        if (index > -1) {\n          requestIdleCallbacks.splice(index, 1);\n          _callTimer(id, performanceNow(), true);\n        }\n        delete requestIdleCallbackTimeouts[id];\n        if (requestIdleCallbacks.length === 0) {\n          Timing.setSendIdleEvents(false);\n        }\n      }, timeout);\n      requestIdleCallbackTimeouts[id] = timeoutId;\n    }\n    return id;\n  },\n\n  cancelIdleCallback: function(timerID: number) {\n    _freeCallback(timerID);\n    const index = requestIdleCallbacks.indexOf(timerID);\n    if (index !== -1) {\n      requestIdleCallbacks.splice(index, 1);\n    }\n\n    const timeoutId = requestIdleCallbackTimeouts[timerID];\n    if (timeoutId) {\n      JSTimers.clearTimeout(timeoutId);\n      delete requestIdleCallbackTimeouts[timerID];\n    }\n\n    if (requestIdleCallbacks.length === 0) {\n      Timing.setSendIdleEvents(false);\n    }\n  },\n\n  clearTimeout: function(timerID: number) {\n    _freeCallback(timerID);\n  },\n\n  clearInterval: function(timerID: number) {\n    _freeCallback(timerID);\n  },\n\n  clearImmediate: function(timerID: number) {\n    _freeCallback(timerID);\n    const index = immediates.indexOf(timerID);\n    if (index !== -1) {\n      immediates.splice(index, 1);\n    }\n  },\n\n  cancelAnimationFrame: function(timerID: number) {\n    _freeCallback(timerID);\n  },\n\n  /**\n   * This is called from the native side. We are passed an array of timerIDs,\n   * and\n   */\n  callTimers: function(timersToCall: Array<number>) {\n    invariant(\n      timersToCall.length !== 0,\n      'Cannot call `callTimers` with an empty list of IDs.',\n    );\n\n    // $FlowFixMe: optionals do not allow assignment from null\n    errors = null;\n    for (let i = 0; i < timersToCall.length; i++) {\n      _callTimer(timersToCall[i], 0);\n    }\n\n    if (errors) {\n      const errorCount = errors.length;\n      if (errorCount > 1) {\n        // Throw all the other errors in a setTimeout, which will throw each\n        // error one at a time\n        for (let ii = 1; ii < errorCount; ii++) {\n          JSTimers.setTimeout(\n            (error => {\n              throw error;\n            }).bind(null, errors[ii]),\n            0,\n          );\n        }\n      }\n      throw errors[0];\n    }\n  },\n\n  callIdleCallbacks: function(frameTime: number) {\n    if (\n      FRAME_DURATION - (performanceNow() - frameTime) <\n      IDLE_CALLBACK_FRAME_DEADLINE\n    ) {\n      return;\n    }\n\n    // $FlowFixMe: optionals do not allow assignment from null\n    errors = null;\n    if (requestIdleCallbacks.length > 0) {\n      const passIdleCallbacks = requestIdleCallbacks.slice();\n      requestIdleCallbacks = [];\n\n      for (let i = 0; i < passIdleCallbacks.length; ++i) {\n        _callTimer(passIdleCallbacks[i], frameTime);\n      }\n    }\n\n    if (requestIdleCallbacks.length === 0) {\n      Timing.setSendIdleEvents(false);\n    }\n\n    if (errors) {\n      errors.forEach(error =>\n        JSTimers.setTimeout(() => {\n          throw error;\n        }, 0),\n      );\n    }\n  },\n\n  /**\n   * This is called after we execute any command we receive from native but\n   * before we hand control back to native.\n   */\n  callImmediates() {\n    errors = null;\n    while (_callImmediatesPass()) {}\n    if (errors) {\n      errors.forEach(error =>\n        JSTimers.setTimeout(() => {\n          throw error;\n        }, 0),\n      );\n    }\n  },\n\n  /**\n   * Called from native (in development) when environment times are out-of-sync.\n   */\n  emitTimeDriftWarning(warningMessage: string) {\n    if (hasEmittedTimeDriftWarning) {\n      return;\n    }\n    hasEmittedTimeDriftWarning = true;\n    console.warn(warningMessage);\n  },\n};\n\nif (!Timing) {\n  console.warn(\"Timing native module is not available, can't set timers.\");\n  // $FlowFixMe: we can assume timers are generally available\n  module.exports = ({\n    callImmediates: JSTimers.callImmediates,\n    setImmediate: JSTimers.setImmediate,\n  }: typeof JSTimers);\n} else {\n  module.exports = JSTimers;\n}\n"]}