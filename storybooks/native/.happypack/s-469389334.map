{"version":3,"sources":["node_modules/react-native/Libraries/Components/Navigation/NavigatorIOS.ios.js"],"names":["EventEmitter","require","Image","RCTNavigatorManager","NavigatorManager","React","PropTypes","ReactNative","StaticContainer","StyleSheet","TVEventHandler","View","ViewPropTypes","createReactClass","invariant","logError","requireNativeComponent","keyMirror","TRANSITIONER_REF","__uid","getuid","NavigatorTransitionerIOS","cb","requestSchedulingJavaScriptNavigation","findNodeHandle","props","Component","SystemIconLabels","done","cancel","edit","save","add","compose","reply","action","organize","bookmarks","search","refresh","stop","camera","trash","play","pause","rewind","undo","redo","SystemIcons","NavigatorIOS","displayName","propTypes","initialRoute","shape","component","func","isRequired","title","string","titleImage","source","passProps","object","backButtonIcon","backButtonTitle","leftButtonIcon","leftButtonTitle","leftButtonSystemIcon","oneOf","Object","keys","onLeftButtonPress","rightButtonIcon","rightButtonTitle","rightButtonSystemIcon","onRightButtonPress","wrapperStyle","style","navigationBarHidden","bool","shadowHidden","tintColor","barTintColor","titleTextColor","translucent","itemWrapperStyle","interactivePopGestureEnabled","navigator","undefined","componentWillMount","push","pop","popN","replace","replaceAtIndex","replacePrevious","replacePreviousAndPop","resetTo","popToRoute","popToTop","componentDidMount","_enableTVEventHandler","componentWillUnmount","_disableTVEventHandler","getDefaultProps","getInitialState","idStack","routeStack","requestedTopOfStack","observedTopOfStack","progress","fromIndex","toIndex","makingNavigatorRequest","updatingAllIndicesAtOrBeyond","_toFocusOnNavigationComplete","_handleFocusRequest","item","state","_getFocusEmitter","emit","_focusEmitter","focusEmitter","getChildContext","onFocusRequested","childContextTypes","instanceOf","_tryLockNavigator","refs","requestSchedulingNavigation","acquiredLock","_handleNavigatorStackChanged","e","newObservedTopOfStack","nativeEvent","stackLength","wasWaitingForConfirmation","nextState","setState","_eliminateUnneededChildren","length","slice","route","nextStack","concat","nextIDStack","n","newRequestedTopOfStack","index","nextRouteStack","indexOfRoute","indexOf","numToPop","_handleNavigationComplete","stopPropagation","_routeToStackItem","routeArg","i","shouldUpdateChild","styles","stackItem","_renderNavigationStackItems","shouldRecurseToNavigator","items","map","transitioner","vertical","_tvEventHandler","enable","cmp","evt","eventType","disable","render","create","backgroundColor","overflow","position","top","left","right","bottom","flex","RCTNavigator","RCTNavigatorItem","module","exports"],"mappings":";;;;;;;;;;;AAWA,a;;AAEA,GAAIA,cAAeC,QAAQ,cAAR,CAAnB;AACA,GAAIC,OAAQD,QAAQ,OAAR,CAAZ;AACA,GAAIE,qBAAsBF,QAAQ,eAAR,EAAyBG,gBAAnD;AACA,GAAIC,OAAQJ,QAAQ,OAAR,CAAZ;AACA,GAAIK,WAAYL,QAAQ,YAAR,CAAhB;AACA,GAAIM,aAAcN,QAAQ,aAAR,CAAlB;AACA,GAAIO,iBAAkBP,QAAQ,uBAAR,CAAtB;AACA,GAAIQ,YAAaR,QAAQ,YAAR,CAAjB;AACA,GAAIS,gBAAiBT,QAAQ,gBAAR,CAArB;AACA,GAAIU,MAAOV,QAAQ,MAAR,CAAX;AACA,GAAIW,eAAgBX,QAAQ,eAAR,CAApB;;AAEA,GAAIY,kBAAmBZ,QAAQ,oBAAR,CAAvB;AACA,GAAIa,WAAYb,QAAQ,oBAAR,CAAhB;AACA,GAAIc,UAAWd,QAAQ,UAAR,CAAf;AACA,GAAIe,wBAAyBf,QAAQ,wBAAR,CAA7B;;AAEA,GAAMgB,WAAYhB,QAAQ,oBAAR,CAAlB;;AAEA,GAAIiB,kBAAmB,iBAAvB;;AAEA,GAAIC,OAAQ,CAAZ;AACA,QAASC,OAAT,EAAkB;AAChB,MAAOD,QAAP;AACD,C;;AAEKE,wB;AACwBC,E,CAAI;AAC9BnB,oBAAoBoB,qCAApB;AACEhB,YAAYiB,cAAZ,CAA2B,IAA3B,CADF;AAEET,QAFF;AAGEO,EAHF;;AAKD,C;;AAEQ;AACP;AACE,oBAAC,YAAD,aAAkB,KAAKG,KAAvB,mDADF;;AAGD,C,sCAboCpB,MAAMqB,S;;;AAgB7C,GAAMC,kBAAmB;AACvBC,KAAM,IADiB;AAEvBC,OAAQ,IAFe;AAGvBC,KAAM,IAHiB;AAIvBC,KAAM,IAJiB;AAKvBC,IAAK,IALkB;AAMvBC,QAAS,IANc;AAOvBC,MAAO,IAPgB;AAQvBC,OAAQ,IARe;AASvBC,SAAU,IATa;AAUvBC,UAAW,IAVY;AAWvBC,OAAQ,IAXe;AAYvBC,QAAS,IAZc;AAavBC,KAAM,IAbiB;AAcvBC,OAAQ,IAde;AAevBC,MAAO,IAfgB;AAgBvBC,KAAM,IAhBiB;AAiBvBC,MAAO,IAjBgB;AAkBvBC,OAAQ,IAlBe;AAmBvB,eAAgB,IAnBO;AAoBvBC,KAAM,IApBiB;AAqBvBC,KAAM,IArBiB;AAsBvB,YAAa,IAtBU,CAAzB;;AAwBA,GAAMC,aAAc/B,UAAUU,gBAAV,CAApB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoOA,GAAIsB,cAAepC,iBAAiB;AAClCqC,YAAa,cADqB;;AAGlCC,UAAW;;;;;;;AAOTC,aAAc9C,UAAU+C,KAAV,CAAgB;;;;AAI5BC,UAAWhD,UAAUiD,IAAV,CAAeC,UAJE;;;;;;AAU5BC,MAAOnD,UAAUoD,MAAV,CAAiBF,UAVI;;;;;AAe5BG,WAAYzD,MAAMiD,SAAN,CAAgBS,MAfA;;;;;;;AAsB5BC,UAAWvD,UAAUwD,MAtBO;;;;;;;AA6B5BC,eAAgB7D,MAAMiD,SAAN,CAAgBS,MA7BJ;;;;;;;AAoC5BI,gBAAiB1D,UAAUoD,MApCC;;;;;;AA0C5BO,eAAgB/D,MAAMiD,SAAN,CAAgBS,MA1CJ;;;;;AA+C5BM,gBAAiB5D,UAAUoD,MA/CC;;;;;;;;;;AAyD5BS,qBAAsB7D,UAAU8D,KAAV,CAAgBC,OAAOC,IAAP,CAAYtB,WAAZ,CAAhB,CAzDM;;;;;;AA+D5BuB,kBAAmBjE,UAAUiD,IA/DD;;;;;;AAqE5BiB,gBAAiBtE,MAAMiD,SAAN,CAAgBS,MArEL;;;;;AA0E5Ba,iBAAkBnE,UAAUoD,MA1EA;;;;;;;AAiF5BgB,sBAAuBpE,UAAU8D,KAAV,CAAgBC,OAAOC,IAAP,CAAYtB,WAAZ,CAAhB,CAjFK;;;;;;AAuF5B2B,mBAAoBrE,UAAUiD,IAvFF;;;;;AA4F5BqB,aAAchE,cAAciE,KA5FA;;;;;AAiG5BC,oBAAqBxE,UAAUyE,IAjGH;;;;;;AAuG5BC,aAAc1E,UAAUyE,IAvGI;;;;;AA4G5BE,UAAW3E,UAAUoD,MA5GO;;;;;AAiH5BwB,aAAc5E,UAAUoD,MAjHI;;;;;AAsH5ByB,eAAgB7E,UAAUoD,MAtHE;;;;;;AA4H5B0B,YAAa9E,UAAUyE,IA5HK,CAAhB;;AA8HXvB,UArIM;;;;;;AA2ITsB,oBAAqBxE,UAAUyE,IA3ItB;;;;;;AAiJTC,aAAc1E,UAAUyE,IAjJf;;;;;;AAuJTM,iBAAkBzE,cAAciE,KAvJvB;;;;;AA4JTI,UAAW3E,UAAUoD,MA5JZ;;;;;AAiKTwB,aAAc5E,UAAUoD,MAjKf;;;;;AAsKTyB,eAAgB7E,UAAUoD,MAtKjB;;;;;;AA4KT0B,YAAa9E,UAAUyE,IA5Kd;;;;;;;;;;;;;AAyLTO,6BAA8BhF,UAAUyE,IAzL/B,CAHuB;;;;AAgMlCQ,UAAYC,SAhMsB;;AAkMlCC,mBAAoB,6BAAW;;;AAG7B,KAAKF,SAAL,CAAiB;AACfG,KAAM,KAAKA,IADI;AAEfC,IAAK,KAAKA,GAFK;AAGfC,KAAM,KAAKA,IAHI;AAIfC,QAAS,KAAKA,OAJC;AAKfC,eAAgB,KAAKA,cALN;AAMfC,gBAAiB,KAAKA,eANP;AAOfC,sBAAuB,KAAKA,qBAPb;AAQfC,QAAS,KAAKA,OARC;AASfC,WAAY,KAAKA,UATF;AAUfC,SAAU,KAAKA,QAVA,CAAjB;;AAYD,CAjNiC;;AAmNlCC,kBAAmB,4BAAW;AAC5B,KAAKC,qBAAL;AACD,CArNiC;;AAuNlCC,qBAAsB,+BAAW;AAC/B,KAAKC,sBAAL;AACD,CAzNiC;;AA2NlCC,gBAAiB,0BAAmB;AAClC,MAAO;AACLpB,YAAa,IADR,CAAP;;AAGD,CA/NiC;;AAiOlCqB,gBAAiB,0BAAkB;AACjC,MAAO;AACLC,QAAS,CAACtF,QAAD,CADJ;AAELuF,WAAY,CAAC,KAAKlF,KAAL,CAAW2B,YAAZ,CAFP;;AAILwD,oBAAqB,CAJhB;;;;;;;AAWLC,mBAAoB,CAXf;AAYLC,SAAU,CAZL;AAaLC,UAAW,CAbN;AAcLC,QAAS,CAdJ;;;AAiBLC,uBAAwB,KAjBnB;;;;AAqBLC,6BAA8B,CArBzB,CAAP;;AAuBD,CAzPiC;;AA2PlCC,6BAA+B3B,SA3PG;;AA6PlC4B,oBAAqB,6BAASC,IAAT,CAAoB;AACvC,GAAI,KAAKC,KAAL,CAAWL,sBAAf,CAAuC;AACrC,KAAKE,4BAAL,CAAoCE,IAApC;AACD,CAFD,IAEO;AACL,KAAKE,gBAAL,GAAwBC,IAAxB,CAA6B,OAA7B,CAAsCH,IAAtC;AACD;AACF,CAnQiC;;AAqQlCI,cAAgBjC,SArQkB;;AAuQlC+B,iBAAkB,2BAAyB;;AAEzC,GAAIG,cAAe,KAAKD,aAAxB;AACA,GAAI,CAACC,YAAL,CAAmB;AACjBA,aAAe,GAAI1H,aAAJ,EAAf;AACA,KAAKyH,aAAL,CAAqBC,YAArB;AACD;AACD,MAAOA,aAAP;AACD,CA/QiC;;AAiRlCC,gBAAiB;;;AAGf;AACA,MAAO;AACLC,iBAAkB,KAAKR,mBADlB;AAELM,aAAc,KAAKH,gBAAL,EAFT,CAAP;;AAID,CAzRiC;;AA2RlCM,kBAAmB;AACjBD,iBAAkBtH,UAAUiD,IADX;AAEjBmE,aAAcpH,UAAUwH,UAAV,CAAqB9H,YAArB,CAFG,CA3Re;;;AAgSlC+H,kBAAmB,2BAASzG,EAAT,CAAyB;AAC1C,KAAK0G,IAAL,CAAU9G,gBAAV,EAA4B+G,2BAA5B;AACE,SAACC,YAAD,QAAkBA,eAAgB5G,IAAlC,EADF;;AAGD,CApSiC;;AAsSlC6G,6BAA8B,sCAASC,CAAT,CAAmB;AAC/C,GAAIC,uBAAwBD,EAAEE,WAAF,CAAcC,WAAd,CAA4B,CAAxD;;AAEAzH;AACEuH,uBAAyB,KAAKf,KAAL,CAAWV,mBADtC;AAEE,sEAFF,CAE0EyB,qBAF1E,CAEiG,KAAKf,KAAL,CAAWV,mBAF5G;;AAIA,GAAI4B;AACF,KAAKlB,KAAL,CAAWV,mBAAX,GAAmC,KAAKU,KAAL,CAAWT,kBADhD;AAEA,GAAI2B,yBAAJ,CAA+B;AAC7B1H;AACEuH,wBAA0B,KAAKf,KAAL,CAAWV,mBADvC;AAEE;AACA,kEAHF;;AAKD;;;;;;;;;;AAUD,GAAI6B,WAAY;AACd5B,mBAAoBwB,qBADN;AAEdpB,uBAAwB,KAFV;AAGdC,6BAA8B,IAHhB;AAIdJ,SAAU,CAJI;AAKdE,QAASqB,qBALK;AAMdtB,UAAWsB,qBANG,CAAhB;;AAQA,KAAKK,QAAL,CAAcD,SAAd,CAAyB,KAAKE,0BAA9B;AACD,CAxUiC;;AA0UlCA,2BAA4B,qCAAW;;;;AAIrC,GAAIzB;AACF,KAAKI,KAAL,CAAWX,UAAX,CAAsBiC,MAAtB,CAA+B,KAAKtB,KAAL,CAAWT,kBAAX,CAAgC,CAA/D;AACA,KAAKS,KAAL,CAAWT,kBAAX,CAAgC,CADhC;AAEA,IAHF;AAIA,KAAK6B,QAAL,CAAc;AACZhC,QAAS,KAAKY,KAAL,CAAWZ,OAAX,CAAmBmC,KAAnB,CAAyB,CAAzB,CAA4B,KAAKvB,KAAL,CAAWT,kBAAX,CAAgC,CAA5D,CADG;AAEZF,WAAY,KAAKW,KAAL,CAAWX,UAAX,CAAsBkC,KAAtB,CAA4B,CAA5B,CAA+B,KAAKvB,KAAL,CAAWT,kBAAX,CAAgC,CAA/D,CAFA;;AAIZD,oBAAqB,KAAKU,KAAL,CAAWT,kBAJpB;AAKZI,uBAAwB,IALZ;AAMZC,6BAA8BA,4BANlB,CAAd;;AAQD,CA1ViC;;;;;;AAgWlCxB,KAAM,cAASoD,KAAT,CAAuB;AAC3BhI,UAAU,CAAC,CAACgI,KAAZ,CAAmB,2BAAnB;;AAEA,GAAI,KAAKxB,KAAL,CAAWV,mBAAX,GAAmC,KAAKU,KAAL,CAAWT,kBAAlD,CAAsE;AACpE,KAAKkB,iBAAL,CAAuB,UAAM;;AAE3B,GAAIgB,WAAY,OAAKzB,KAAL,CAAWX,UAAX,CAAsBqC,MAAtB,CAA6B,CAACF,KAAD,CAA7B,CAAhB;AACA,GAAIG,aAAc,OAAK3B,KAAL,CAAWZ,OAAX,CAAmBsC,MAAnB,CAA0B,CAAC5H,QAAD,CAA1B,CAAlB;AACA,OAAKsH,QAAL,CAAc;;;AAGZhC,QAASuC,WAHG;AAIZtC,WAAYoC,SAJA;AAKZnC,oBAAqBmC,UAAUH,MAAV,CAAmB,CAL5B;AAMZ3B,uBAAwB,IANZ;AAOZC,6BAA8B6B,UAAUH,MAAV,CAAmB,CAPrC,CAAd;;AASD,CAbD;AAcD;AACF,CAnXiC;;;;;;AAyXlChD,KAAM,cAASsD,CAAT,CAAoB;AACxB,GAAIA,IAAM,CAAV,CAAa;AACX;AACD;;AAED,GAAI,KAAK5B,KAAL,CAAWV,mBAAX,GAAmC,KAAKU,KAAL,CAAWT,kBAAlD,CAAsE;AACpE,GAAI,KAAKS,KAAL,CAAWV,mBAAX,CAAiC,CAArC,CAAwC;AACtC,KAAKmB,iBAAL,CAAuB,UAAM;AAC3B,GAAIoB,wBAAyB,OAAK7B,KAAL,CAAWV,mBAAX,CAAiCsC,CAA9D;AACApI,UAAUqI,wBAA0B,CAApC,CAAuC,oBAAvC;AACA,OAAKT,QAAL,CAAc;AACZ9B,oBAAqBuC,sBADT;AAEZlC,uBAAwB,IAFZ;AAGZC,6BAA8B,OAAKI,KAAL,CAAWV,mBAAX,CAAiCsC,CAHnD,CAAd;;AAKD,CARD;AASD;AACF;AACF,CA3YiC;;;;;AAgZlCvD,IAAK,cAAW;AACd,KAAKC,IAAL,CAAU,CAAV;AACD,CAlZiC;;;;;;;;;AA2ZlCE,eAAgB,wBAASgD,KAAT,CAAuBM,KAAvB,CAAsC;AACpDtI,UAAU,CAAC,CAACgI,KAAZ,CAAmB,8BAAnB;AACA,GAAIM,MAAQ,CAAZ,CAAe;AACbA,OAAS,KAAK9B,KAAL,CAAWX,UAAX,CAAsBiC,MAA/B;AACD;;AAED,GAAI,KAAKtB,KAAL,CAAWX,UAAX,CAAsBiC,MAAtB,EAAgCQ,KAApC,CAA2C;AACzC;AACD;;;;AAID,GAAIH,aAAc,KAAK3B,KAAL,CAAWZ,OAAX,CAAmBmC,KAAnB,EAAlB;AACA,GAAIQ,gBAAiB,KAAK/B,KAAL,CAAWX,UAAX,CAAsBkC,KAAtB,EAArB;AACAI,YAAYG,KAAZ,EAAqBhI,QAArB;AACAiI,eAAeD,KAAf,EAAwBN,KAAxB;;AAEA,KAAKJ,QAAL,CAAc;AACZhC,QAASuC,WADG;AAEZtC,WAAY0C,cAFA;AAGZpC,uBAAwB,KAHZ;AAIZC,6BAA8BkC,KAJlB,CAAd;;;AAOD,CAnbiC;;;;;;;AA0blCvD,QAAS,iBAASiD,KAAT,CAAuB;AAC9B,KAAKhD,cAAL,CAAoBgD,KAApB,CAA2B,CAAC,CAA5B;AACD,CA5biC;;;;;;AAkclC/C,gBAAiB,yBAAS+C,KAAT,CAAuB;AACtC,KAAKhD,cAAL,CAAoBgD,KAApB,CAA2B,CAAC,CAA5B;AACD,CApciC;;;;;AAyclC3C,SAAU,mBAAW;AACnB,KAAKD,UAAL,CAAgB,KAAKoB,KAAL,CAAWX,UAAX,CAAsB,CAAtB,CAAhB;AACD,CA3ciC;;;;;;AAidlCT,WAAY,oBAAS4C,KAAT,CAAuB;AACjC,GAAIQ,cAAe,KAAKhC,KAAL,CAAWX,UAAX,CAAsB4C,OAAtB,CAA8BT,KAA9B,CAAnB;AACAhI;AACEwI,eAAiB,CAAC,CADpB;AAEE,uDAFF;;AAIA,GAAIE,UAAW,KAAKlC,KAAL,CAAWX,UAAX,CAAsBiC,MAAtB,CAA+BU,YAA/B,CAA8C,CAA7D;AACA,KAAK1D,IAAL,CAAU4D,QAAV;AACD,CAzdiC;;;;;;AA+dlCxD,sBAAuB,+BAAS8C,KAAT,CAAuB;;AAE5C,GAAI,KAAKxB,KAAL,CAAWV,mBAAX,GAAmC,KAAKU,KAAL,CAAWT,kBAAlD,CAAsE;AACpE;AACD;AACD,GAAI,KAAKS,KAAL,CAAWX,UAAX,CAAsBiC,MAAtB,CAA+B,CAAnC,CAAsC;AACpC;AACD;AACD,KAAKb,iBAAL,CAAuB,UAAM;AAC3B,OAAKhC,eAAL,CAAqB+C,KAArB;AACA,OAAKJ,QAAL,CAAc;AACZ9B,oBAAqB,OAAKU,KAAL,CAAWV,mBAAX,CAAiC,CAD1C;AAEZK,uBAAwB,IAFZ,CAAd;;AAID,CAND;AAOD,CA9eiC;;;;;;AAoflChB,QAAS,iBAAS6C,KAAT,CAAuB;AAC9BhI,UAAU,CAAC,CAACgI,KAAZ,CAAmB,2BAAnB;;AAEA,GAAI,KAAKxB,KAAL,CAAWV,mBAAX,GAAmC,KAAKU,KAAL,CAAWT,kBAAlD,CAAsE;AACpE;AACD;AACD,KAAKf,cAAL,CAAoBgD,KAApB,CAA2B,CAA3B;AACA,KAAK5C,UAAL,CAAgB4C,KAAhB;AACD,CA5fiC;;AA8flCW,0BAA2B,mCAASrB,CAAT,CAAmB;;AAE5CA,EAAEsB,eAAF;;AAEA,GAAI,KAAKvC,4BAAT,CAAuC;AACrC,KAAKI,gBAAL,GAAwBC,IAAxB,CAA6B,OAA7B,CAAsC,KAAKL,4BAA3C;AACA,KAAKA,4BAAL,CAAoC,IAApC;AACD;AACD,KAAKgB,4BAAL,CAAkCC,CAAlC;AACD,CAvgBiC;;AAygBlCuB,kBAAmB,2BAASC,QAAT,CAA0BC,CAA1B,CAAqC;AACjDvG,SADiD,CACDsG,QADC,CACjDtG,SADiD,CACtCsB,YADsC,CACDgF,QADC,CACtChF,YADsC,CACxBf,SADwB,CACD+F,QADC,CACxB/F,SADwB,CACViF,KADU,0BACDc,QADC;AAEnB,KAAKnI,KAFc,CAEjD4D,gBAFiD,QAEjDA,gBAFiD,CAE5B5D,KAF4B;AAGtD,GAAIqI;AACF,KAAKxC,KAAL,CAAWJ,4BAAX,EAA2C,IAA3C;AACA,KAAKI,KAAL,CAAWJ,4BAAX,EAA2C2C,CAF7C;AAGA,GAAInI,WAAY4B,SAAhB;AACA;AACE,oBAAC,eAAD,EAAiB,IAAK,MAAQuG,CAA9B,CAAiC,aAAcC,iBAA/C;AACE,oBAAC,gBAAD;AACMrI,KADN;AAEMqH,KAFN;AAGE,MAAO;AACLiB,OAAOC,SADF;AAEL3E,gBAFK;AAGLT,YAHK,CAHT;;AAQE,oBAAC,SAAD;AACE,UAAW,KAAKW,SADlB;AAEE,MAAOuD,KAFT;AAGMjF,SAHN,oDARF,CADF,CADF;;;;;AAkBD,CAliBiC;;AAoiBlCoG,4BAA6B,sCAAW;AACtC,GAAIC;AACF,KAAK5C,KAAL,CAAWL,sBAAX;AACA,KAAKK,KAAL,CAAWJ,4BAAX,GAA4C,IAF9C;;;AAKA,GAAIiD,OAAQD;AACV,KAAK5C,KAAL,CAAWX,UAAX,CAAsByD,GAAtB,CAA0B,KAAKT,iBAA/B,CADU,CAC0C,IADtD;AAEA;AACE,oBAAC,eAAD,EAAiB,aAAcO,wBAA/B;AACE,oBAAC,wBAAD;AACE,IAAKhJ,gBADP;AAEE,MAAO6I,OAAOM,YAFhB;;AAIE,SAAU,KAAK5I,KAAL,CAAW6I,QAJvB;AAKE,oBAAqB,KAAKhD,KAAL,CAAWV,mBALlC;AAME,qBAAsB,KAAK6C,yBAN7B;AAOE,6BAA8B,KAAKhI,KAAL,CAAW6D,4BAP3C;AAQG6E,KARH,CADF,CADF;;;;AAcD,CA1jBiC;;AA4jBlCI,gBAAkB/E,SA5jBgB;;AA8jBlCa,sBAAuB,gCAAW;AAChC,KAAKkE,eAAL,CAAuB,GAAI7J,eAAJ,EAAvB;AACA,KAAK6J,eAAL,CAAqBC,MAArB,CAA4B,IAA5B,CAAkC,SAASC,GAAT,CAAcC,GAAd,CAAmB;AACnD,GAAIA,KAAOA,IAAIC,SAAJ,GAAkB,MAA7B,CAAqC;AACnCF,IAAI9E,GAAJ;AACD;AACF,CAJD;AAKD,CArkBiC;;AAukBlCY,uBAAwB,iCAAW;AACjC,GAAI,KAAKgE,eAAT,CAA0B;AACxB,KAAKA,eAAL,CAAqBK,OAArB;AACA,MAAO,MAAKL,eAAZ;AACD;AACF,CA5kBiC;;AA8kBlCM,OAAQ,iBAAW;AACjB;;AAEE,oBAAC,IAAD,EAAM,MAAO,KAAKpJ,KAAL,CAAWoD,KAAxB;AACG,KAAKoF,2BAAL,EADH,CAFF;;;AAMD,CArlBiC,CAAjB,CAAnB;;;AAwlBA,GAAIF,QAAStJ,WAAWqK,MAAX,CAAkB;AAC7Bd,UAAW;AACTe,gBAAiB,OADR;AAETC,SAAU,QAFD;AAGTC,SAAU,UAHD;AAITC,IAAK,CAJI;AAKTC,KAAM,CALG;AAMTC,MAAO,CANE;AAOTC,OAAQ,CAPC,CADkB;;AAU7BhB,aAAc;AACZiB,KAAM,CADM,CAVe,CAAlB,CAAb;;;;AAeA,GAAIC,cAAevK,uBAAuB,cAAvB,CAAnB;AACA,GAAIwK,kBAAmBxK,uBAAuB,YAAvB,CAAvB;;AAEAyK,OAAOC,OAAP,CAAiBzI,YAAjB,C,0GA94BI9C,mB,uLAiBAe,gB,oLAEAC,K,yKACKC,M,0KAIHC,wB,4LAgBAM,gB,oLAwBAqB,W,+KAoOFC,Y,gLAwlBA8G,M,0KAeAwB,Y,gLACAC,gB","file":"NavigatorIOS.ios.js","sourceRoot":"/home/phz/workspace/brimitives/storybooks/native","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule NavigatorIOS\n * @flow\n */\n'use strict';\n\nvar EventEmitter = require('EventEmitter');\nvar Image = require('Image');\nvar RCTNavigatorManager = require('NativeModules').NavigatorManager;\nvar React = require('React');\nvar PropTypes = require('prop-types');\nvar ReactNative = require('ReactNative');\nvar StaticContainer = require('StaticContainer.react');\nvar StyleSheet = require('StyleSheet');\nvar TVEventHandler = require('TVEventHandler');\nvar View = require('View');\nvar ViewPropTypes = require('ViewPropTypes');\n\nvar createReactClass = require('create-react-class');\nvar invariant = require('fbjs/lib/invariant');\nvar logError = require('logError');\nvar requireNativeComponent = require('requireNativeComponent');\n\nconst keyMirror = require('fbjs/lib/keyMirror');\n\nvar TRANSITIONER_REF = 'transitionerRef';\n\nvar __uid = 0;\nfunction getuid() {\n  return __uid++;\n}\n\nclass NavigatorTransitionerIOS extends React.Component {\n  requestSchedulingNavigation(cb) {\n    RCTNavigatorManager.requestSchedulingJavaScriptNavigation(\n      ReactNative.findNodeHandle(this),\n      logError,\n      cb\n    );\n  }\n\n  render() {\n    return (\n      <RCTNavigator {...this.props}/>\n    );\n  }\n}\n\nconst SystemIconLabels = {\n  done: true,\n  cancel: true,\n  edit: true,\n  save: true,\n  add: true,\n  compose: true,\n  reply: true,\n  action: true,\n  organize: true,\n  bookmarks: true,\n  search: true,\n  refresh: true,\n  stop: true,\n  camera: true,\n  trash: true,\n  play: true,\n  pause: true,\n  rewind: true,\n  'fast-forward': true,\n  undo: true,\n  redo: true,\n  'page-curl': true,\n};\nconst SystemIcons = keyMirror(SystemIconLabels);\n\ntype SystemButtonType = $Enum<typeof SystemIconLabels>;\n\ntype Route = {\n  component: Function,\n  title: string,\n  titleImage?: Object,\n  passProps?: Object,\n  backButtonTitle?: string,\n  backButtonIcon?: Object,\n  leftButtonTitle?: string,\n  leftButtonIcon?: Object,\n  leftButtonSystemIcon?: SystemButtonType,\n  onLeftButtonPress?: Function,\n  rightButtonTitle?: string,\n  rightButtonIcon?: Object,\n  rightButtonSystemIcon?: SystemButtonType,\n  onRightButtonPress?: Function,\n  wrapperStyle?: any,\n};\n\ntype State = {\n  idStack: Array<number>,\n  routeStack: Array<Route>,\n  requestedTopOfStack: number,\n  observedTopOfStack: number,\n  progress: number,\n  fromIndex: number,\n  toIndex: number,\n  makingNavigatorRequest: boolean,\n  updatingAllIndicesAtOrBeyond: ?number,\n}\n\ntype Event = Object;\n\n/**\n * Think of `<NavigatorIOS>` as simply a component that renders an\n * `RCTNavigator`, and moves the `RCTNavigator`'s `requestedTopOfStack` pointer\n * forward and backward. The `RCTNavigator` interprets changes in\n * `requestedTopOfStack` to be pushes and pops of children that are rendered.\n * `<NavigatorIOS>` always ensures that whenever the `requestedTopOfStack`\n * pointer is moved, that we've also rendered enough children so that the\n * `RCTNavigator` can carry out the push/pop with those children.\n * `<NavigatorIOS>` also removes children that will no longer be needed\n * (after the pop of a child has been fully completed/animated out).\n */\n\n/**\n * `NavigatorIOS` is a wrapper around\n * [`UINavigationController`](https://developer.apple.com/library/ios/documentation/UIKit/Reference/UINavigationController_Class/),\n * enabling you to implement a navigation stack. It works exactly the same as it\n * would on a native app using `UINavigationController`, providing the same\n * animations and behavior from UIKit.\n *\n * As the name implies, it is only available on iOS. Take a look at\n * [`React Navigation`](https://reactnavigation.org/) for a cross-platform\n * solution in JavaScript, or check out either of these components for native\n * solutions: [native-navigation](http://airbnb.io/native-navigation/),\n * [react-native-navigation](https://github.com/wix/react-native-navigation).\n *\n * To set up the navigator, provide the `initialRoute` prop with a route\n * object. A route object is used to describe each scene that your app\n * navigates to. `initialRoute` represents the first route in your navigator.\n *\n * ```\n * import React, { Component, PropTypes } from 'react';\n * import { NavigatorIOS, Text } from 'react-native';\n *\n * export default class NavigatorIOSApp extends Component {\n *   render() {\n *     return (\n *       <NavigatorIOS\n *         initialRoute={{\n *           component: MyScene,\n *           title: 'My Initial Scene',\n *         }}\n *         style={{flex: 1}}\n *       />\n *     );\n *   }\n * }\n *\n * class MyScene extends Component {\n *   static propTypes = {\n *     title: PropTypes.string.isRequired,\n *     navigator: PropTypes.object.isRequired,\n *   }\n *\n *   _onForward = () => {\n *     this.props.navigator.push({\n *       title: 'Scene ' + nextIndex,\n *     });\n *   }\n *\n *   render() {\n *     return (\n *       <View>\n *         <Text>Current Scene: { this.props.title }</Text>\n *         <TouchableHighlight onPress={this._onForward}>\n *           <Text>Tap me to load the next scene</Text>\n *         </TouchableHighlight>\n *       </View>\n *     )\n *   }\n * }\n * ```\n *\n * In this code, the navigator renders the component specified in initialRoute,\n * which in this case is `MyScene`. This component will receive a `route` prop\n * and a `navigator` prop representing the navigator. The navigator's navigation\n * bar will render the title for the current scene, \"My Initial Scene\".\n *\n * You can optionally pass in a `passProps` property to your `initialRoute`.\n * `NavigatorIOS` passes this in as props to the rendered component:\n *\n * ```\n * initialRoute={{\n *   component: MyScene,\n *   title: 'My Initial Scene',\n *   passProps: { myProp: 'foo' }\n * }}\n * ```\n *\n * You can then access the props passed in via `{this.props.myProp}`.\n *\n * #### Handling Navigation\n *\n * To trigger navigation functionality such as pushing or popping a view, you\n * have access to a `navigator` object. The object is passed in as a prop to any\n * component that is rendered by `NavigatorIOS`. You can then call the\n * relevant methods to perform the navigation action you need:\n *\n * ```\n * class MyView extends Component {\n *   _handleBackPress() {\n *     this.props.navigator.pop();\n *   }\n *\n *   _handleNextPress(nextRoute) {\n *     this.props.navigator.push(nextRoute);\n *   }\n *\n *   render() {\n *     const nextRoute = {\n *       component: MyView,\n *       title: 'Bar That',\n *       passProps: { myProp: 'bar' }\n *     };\n *     return(\n *       <TouchableHighlight onPress={() => this._handleNextPress(nextRoute)}>\n *         <Text style={{marginTop: 200, alignSelf: 'center'}}>\n *           See you on the other nav {this.props.myProp}!\n *         </Text>\n *       </TouchableHighlight>\n *     );\n *   }\n * }\n * ```\n *\n * You can also trigger navigator functionality from the `NavigatorIOS`\n * component:\n *\n * ```\n * class NavvyIOS extends Component {\n *   _handleNavigationRequest() {\n *     this.refs.nav.push({\n *       component: MyView,\n *       title: 'Genius',\n *       passProps: { myProp: 'genius' },\n *     });\n *   }\n *\n *   render() {\n *     return (\n *       <NavigatorIOS\n *         ref='nav'\n *         initialRoute={{\n *           component: MyView,\n *           title: 'Foo This',\n *           passProps: { myProp: 'foo' },\n *           rightButtonTitle: 'Add',\n *           onRightButtonPress: () => this._handleNavigationRequest(),\n *         }}\n *         style={{flex: 1}}\n *       />\n *     );\n *   }\n * }\n * ```\n *\n * The code above adds a `_handleNavigationRequest` private method that is\n * invoked from the `NavigatorIOS` component when the right navigation bar item\n * is pressed. To get access to the navigator functionality, a reference to it\n * is saved in the `ref` prop and later referenced to push a new scene into the\n * navigation stack.\n *\n * #### Navigation Bar Configuration\n *\n * Props passed to `NavigatorIOS` will set the default configuration\n * for the navigation bar. Props passed as properties to a route object will set\n * the configuration for that route's navigation bar, overriding any props\n * passed to the `NavigatorIOS` component.\n *\n * ```\n * _handleNavigationRequest() {\n *   this.refs.nav.push({\n *     //...\n *     passProps: { myProp: 'genius' },\n *     barTintColor: '#996699',\n *   });\n * }\n *\n * render() {\n *   return (\n *     <NavigatorIOS\n *       //...\n *       style={{flex: 1}}\n *       barTintColor='#ffffcc'\n *     />\n *   );\n * }\n * ```\n *\n * In the example above the navigation bar color is changed when the new route\n * is pushed.\n *\n */\nvar NavigatorIOS = createReactClass({\n  displayName: 'NavigatorIOS',\n\n  propTypes: {\n\n    /**\n     * NavigatorIOS uses `route` objects to identify child views, their props,\n     * and navigation bar configuration. Navigation operations such as push\n     * operations expect routes to look like this the `initialRoute`.\n     */\n    initialRoute: PropTypes.shape({\n      /**\n       * The React Class to render for this route\n       */\n      component: PropTypes.func.isRequired,\n\n      /**\n       * The title displayed in the navigation bar and the back button for this\n       * route.\n       */\n      title: PropTypes.string.isRequired,\n\n      /**\n       * If set, a title image will appear instead of the text title.\n       */\n      titleImage: Image.propTypes.source,\n\n      /**\n       * Use this to specify additional props to pass to the rendered\n       * component. `NavigatorIOS` will automatically pass in `route` and\n       * `navigator` props to the comoponent.\n       */\n      passProps: PropTypes.object,\n\n      /**\n       * If set, the left navigation button image will be displayed using this\n       * source. Note that this doesn't apply to the header of the current\n       * view, but to those views that are subsequently pushed.\n       */\n      backButtonIcon: Image.propTypes.source,\n\n      /**\n       * If set, the left navigation button text will be set to this. Note that\n       * this doesn't apply to the left button of the current view, but to\n       * those views that are subsequently pushed\n       */\n      backButtonTitle: PropTypes.string,\n\n      /**\n       * If set, the left navigation button image will be displayed using\n       * this source.\n       */\n      leftButtonIcon: Image.propTypes.source,\n\n      /**\n       * If set, the left navigation button will display this text.\n       */\n      leftButtonTitle: PropTypes.string,\n\n      /**\n       * If set, the left header button will appear with this system icon\n       *\n       * Supported icons are `done`, `cancel`, `edit`, `save`, `add`,\n       * `compose`, `reply`, `action`, `organize`, `bookmarks`, `search`,\n       * `refresh`, `stop`, `camera`, `trash`, `play`, `pause`, `rewind`,\n       * `fast-forward`, `undo`, `redo`, and `page-curl`\n       */\n      leftButtonSystemIcon: PropTypes.oneOf(Object.keys(SystemIcons)),\n\n      /**\n       * This function will be invoked when the left navigation bar item is\n       * pressed.\n       */\n      onLeftButtonPress: PropTypes.func,\n\n      /**\n       * If set, the right navigation button image will be displayed using\n       * this source.\n       */\n      rightButtonIcon: Image.propTypes.source,\n\n      /**\n       * If set, the right navigation button will display this text.\n       */\n      rightButtonTitle: PropTypes.string,\n\n      /**\n       * If set, the right header button will appear with this system icon\n       *\n       * See leftButtonSystemIcon for supported icons\n       */\n      rightButtonSystemIcon: PropTypes.oneOf(Object.keys(SystemIcons)),\n\n      /**\n       * This function will be invoked when the right navigation bar item is\n       * pressed.\n       */\n      onRightButtonPress: PropTypes.func,\n\n      /**\n       * Styles for the navigation item containing the component.\n       */\n      wrapperStyle: ViewPropTypes.style,\n\n      /**\n       * Boolean value that indicates whether the navigation bar is hidden.\n       */\n      navigationBarHidden: PropTypes.bool,\n\n      /**\n       * Boolean value that indicates whether to hide the 1px hairline\n       * shadow.\n       */\n      shadowHidden: PropTypes.bool,\n\n      /**\n       * The color used for the buttons in the navigation bar.\n       */\n      tintColor: PropTypes.string,\n\n      /**\n       * The background color of the navigation bar.\n       */\n      barTintColor: PropTypes.string,\n\n       /**\n       * The text color of the navigation bar title.\n       */\n      titleTextColor: PropTypes.string,\n\n       /**\n       * Boolean value that indicates whether the navigation bar is\n       * translucent.\n       */\n      translucent: PropTypes.bool,\n\n    }).isRequired,\n\n    /**\n     * Boolean value that indicates whether the navigation bar is hidden\n     * by default.\n     */\n    navigationBarHidden: PropTypes.bool,\n\n    /**\n     * Boolean value that indicates whether to hide the 1px hairline shadow\n     * by default.\n     */\n    shadowHidden: PropTypes.bool,\n\n    /**\n     * The default wrapper style for components in the navigator.\n     * A common use case is to set the `backgroundColor` for every scene.\n     */\n    itemWrapperStyle: ViewPropTypes.style,\n\n    /**\n     * The default color used for the buttons in the navigation bar.\n     */\n    tintColor: PropTypes.string,\n\n    /**\n     * The default background color of the navigation bar.\n     */\n    barTintColor: PropTypes.string,\n\n    /**\n     * The default text color of the navigation bar title.\n     */\n    titleTextColor: PropTypes.string,\n\n    /**\n     * Boolean value that indicates whether the navigation bar is\n     * translucent by default\n     */\n    translucent: PropTypes.bool,\n\n    /**\n     * Boolean value that indicates whether the interactive pop gesture is\n     * enabled. This is useful for enabling/disabling the back swipe navigation\n     * gesture.\n     *\n     * If this prop is not provided, the default behavior is for the back swipe\n     * gesture to be enabled when the navigation bar is shown and disabled when\n     * the navigation bar is hidden. Once you've provided the\n     * `interactivePopGestureEnabled` prop, you can never restore the default\n     * behavior.\n     */\n    interactivePopGestureEnabled: PropTypes.bool,\n\n  },\n\n  navigator: (undefined: ?Object),\n\n  componentWillMount: function() {\n    // Precompute a pack of callbacks that's frequently generated and passed to\n    // instances.\n    this.navigator = {\n      push: this.push,\n      pop: this.pop,\n      popN: this.popN,\n      replace: this.replace,\n      replaceAtIndex: this.replaceAtIndex,\n      replacePrevious: this.replacePrevious,\n      replacePreviousAndPop: this.replacePreviousAndPop,\n      resetTo: this.resetTo,\n      popToRoute: this.popToRoute,\n      popToTop: this.popToTop,\n    };\n  },\n\n  componentDidMount: function() {\n    this._enableTVEventHandler();\n  },\n\n  componentWillUnmount: function() {\n    this._disableTVEventHandler();\n  },\n\n  getDefaultProps: function(): Object {\n    return {\n      translucent: true,\n    };\n  },\n\n  getInitialState: function(): State {\n    return {\n      idStack: [getuid()],\n      routeStack: [this.props.initialRoute],\n      // The navigation index that we wish to push/pop to.\n      requestedTopOfStack: 0,\n      // The last index that native has sent confirmation of completed push/pop\n      // for. At this point, we can discard any views that are beyond the\n      // `requestedTopOfStack`. A value of `null` means we have not received\n      // any confirmation, ever. We may receive an `observedTopOfStack` without\n      // ever requesting it - native can instigate pops of its own with the\n      // backswipe gesture.\n      observedTopOfStack: 0,\n      progress: 1,\n      fromIndex: 0,\n      toIndex: 0,\n      // Whether or not we are making a navigator request to push/pop. (Used\n      // for performance optimization).\n      makingNavigatorRequest: false,\n      // Whether or not we are updating children of navigator and if so (not\n      // `null`) which index marks the beginning of all updates. Used for\n      // performance optimization.\n      updatingAllIndicesAtOrBeyond: 0,\n    };\n  },\n\n  _toFocusOnNavigationComplete: (undefined: any),\n\n  _handleFocusRequest: function(item: any) {\n    if (this.state.makingNavigatorRequest) {\n      this._toFocusOnNavigationComplete = item;\n    } else {\n      this._getFocusEmitter().emit('focus', item);\n    }\n  },\n\n  _focusEmitter: (undefined: ?EventEmitter),\n\n  _getFocusEmitter: function(): EventEmitter {\n    // Flow not yet tracking assignments to instance fields.\n    var focusEmitter = this._focusEmitter;\n    if (!focusEmitter) {\n      focusEmitter = new EventEmitter();\n      this._focusEmitter = focusEmitter;\n    }\n    return focusEmitter;\n  },\n\n  getChildContext: function(): {\n    onFocusRequested: Function,\n    focusEmitter: EventEmitter,\n  } {\n    return {\n      onFocusRequested: this._handleFocusRequest,\n      focusEmitter: this._getFocusEmitter(),\n    };\n  },\n\n  childContextTypes: {\n    onFocusRequested: PropTypes.func,\n    focusEmitter: PropTypes.instanceOf(EventEmitter),\n  },\n\n  _tryLockNavigator: function(cb: () => void) {\n    this.refs[TRANSITIONER_REF].requestSchedulingNavigation(\n      (acquiredLock) => acquiredLock && cb()\n    );\n  },\n\n  _handleNavigatorStackChanged: function(e: Event) {\n    var newObservedTopOfStack = e.nativeEvent.stackLength - 1;\n\n    invariant(\n      newObservedTopOfStack <= this.state.requestedTopOfStack,\n      'No navigator item should be pushed without JS knowing about it %s %s', newObservedTopOfStack, this.state.requestedTopOfStack\n    );\n    var wasWaitingForConfirmation =\n      this.state.requestedTopOfStack !== this.state.observedTopOfStack;\n    if (wasWaitingForConfirmation) {\n      invariant(\n        newObservedTopOfStack === this.state.requestedTopOfStack,\n        'If waiting for observedTopOfStack to reach requestedTopOfStack, ' +\n        'the only valid observedTopOfStack should be requestedTopOfStack.'\n      );\n    }\n    // Mark the most recent observation regardless of if we can lock the\n    // navigator. `observedTopOfStack` merely represents what we've observed\n    // and this first `setState` is only executed to update debugging\n    // overlays/navigation bar.\n    // Also reset progress, toIndex, and fromIndex as they might not end\n    // in the correct states for a two possible reasons:\n    // Progress isn't always 0 or 1 at the end, the system rounds\n    // If the Navigator is offscreen these values won't be updated\n    // TOOD: Revisit this decision when no longer relying on native navigator.\n    var nextState = {\n      observedTopOfStack: newObservedTopOfStack,\n      makingNavigatorRequest: false,\n      updatingAllIndicesAtOrBeyond: null,\n      progress: 1,\n      toIndex: newObservedTopOfStack,\n      fromIndex: newObservedTopOfStack,\n    };\n    this.setState(nextState, this._eliminateUnneededChildren);\n  },\n\n  _eliminateUnneededChildren: function() {\n    // Updating the indices that we're deleting and that's all. (Truth: Nothing\n    // even uses the indices in this case, but let's make this describe the\n    // truth anyways).\n    var updatingAllIndicesAtOrBeyond =\n      this.state.routeStack.length > this.state.observedTopOfStack + 1 ?\n      this.state.observedTopOfStack + 1 :\n      null;\n    this.setState({\n      idStack: this.state.idStack.slice(0, this.state.observedTopOfStack + 1),\n      routeStack: this.state.routeStack.slice(0, this.state.observedTopOfStack + 1),\n      // Now we rerequest the top of stack that we observed.\n      requestedTopOfStack: this.state.observedTopOfStack,\n      makingNavigatorRequest: true,\n      updatingAllIndicesAtOrBeyond: updatingAllIndicesAtOrBeyond,\n    });\n  },\n\n  /**\n   * Navigate forward to a new route.\n   * @param route The new route to navigate to.\n   */\n  push: function(route: Route) {\n    invariant(!!route, 'Must supply route to push');\n    // Make sure all previous requests are caught up first. Otherwise reject.\n    if (this.state.requestedTopOfStack === this.state.observedTopOfStack) {\n      this._tryLockNavigator(() => {\n\n        var nextStack = this.state.routeStack.concat([route]);\n        var nextIDStack = this.state.idStack.concat([getuid()]);\n        this.setState({\n          // We have to make sure that we've also supplied enough views to\n          // satisfy our request to adjust the `requestedTopOfStack`.\n          idStack: nextIDStack,\n          routeStack: nextStack,\n          requestedTopOfStack: nextStack.length - 1,\n          makingNavigatorRequest: true,\n          updatingAllIndicesAtOrBeyond: nextStack.length - 1,\n        });\n      });\n    }\n  },\n\n  /**\n   * Go back N scenes at once. When N=1, behavior matches `pop()`.\n   * @param n The number of scenes to pop.\n   */\n  popN: function(n: number) {\n    if (n === 0) {\n      return;\n    }\n    // Make sure all previous requests are caught up first. Otherwise reject.\n    if (this.state.requestedTopOfStack === this.state.observedTopOfStack) {\n      if (this.state.requestedTopOfStack > 0) {\n        this._tryLockNavigator(() => {\n          var newRequestedTopOfStack = this.state.requestedTopOfStack - n;\n          invariant(newRequestedTopOfStack >= 0, 'Cannot pop below 0');\n          this.setState({\n            requestedTopOfStack: newRequestedTopOfStack,\n            makingNavigatorRequest: true,\n            updatingAllIndicesAtOrBeyond: this.state.requestedTopOfStack - n,\n          });\n        });\n      }\n    }\n  },\n\n  /**\n   * Pop back to the previous scene.\n   */\n  pop: function() {\n    this.popN(1);\n  },\n\n  /**\n   * Replace a route in the navigation stack.\n   *\n   * @param route The new route that will replace the specified one.\n   * @param index The route into the stack that should be replaced.\n   *    If it is negative, it counts from the back of the stack.\n   */\n  replaceAtIndex: function(route: Route, index: number) {\n    invariant(!!route, 'Must supply route to replace');\n    if (index < 0) {\n      index += this.state.routeStack.length;\n    }\n\n    if (this.state.routeStack.length <= index) {\n      return;\n    }\n\n    // I don't believe we need to lock for a replace since there's no\n    // navigation actually happening\n    var nextIDStack = this.state.idStack.slice();\n    var nextRouteStack = this.state.routeStack.slice();\n    nextIDStack[index] = getuid();\n    nextRouteStack[index] = route;\n\n    this.setState({\n      idStack: nextIDStack,\n      routeStack: nextRouteStack,\n      makingNavigatorRequest: false,\n      updatingAllIndicesAtOrBeyond: index,\n    });\n\n  },\n\n  /**\n   * Replace the route for the current scene and immediately\n   * load the view for the new route.\n   * @param route The new route to navigate to.\n   */\n  replace: function(route: Route) {\n    this.replaceAtIndex(route, -1);\n  },\n\n  /**\n   * Replace the route/view for the previous scene.\n   * @param route The new route to will replace the previous scene.\n   */\n  replacePrevious: function(route: Route) {\n    this.replaceAtIndex(route, -2);\n  },\n\n  /**\n   * Go back to the topmost item in the navigation stack.\n   */\n  popToTop: function() {\n    this.popToRoute(this.state.routeStack[0]);\n  },\n\n  /**\n   * Go back to the item for a particular route object.\n   * @param route The new route to navigate to.\n   */\n  popToRoute: function(route: Route) {\n    var indexOfRoute = this.state.routeStack.indexOf(route);\n    invariant(\n      indexOfRoute !== -1,\n      'Calling pop to route for a route that doesn\\'t exist!'\n    );\n    var numToPop = this.state.routeStack.length - indexOfRoute - 1;\n    this.popN(numToPop);\n  },\n\n  /**\n   * Replaces the previous route/view and transitions back to it.\n   * @param route The new route that replaces the previous scene.\n   */\n  replacePreviousAndPop: function(route: Route) {\n    // Make sure all previous requests are caught up first. Otherwise reject.\n    if (this.state.requestedTopOfStack !== this.state.observedTopOfStack) {\n      return;\n    }\n    if (this.state.routeStack.length < 2) {\n      return;\n    }\n    this._tryLockNavigator(() => {\n      this.replacePrevious(route);\n      this.setState({\n        requestedTopOfStack: this.state.requestedTopOfStack - 1,\n        makingNavigatorRequest: true,\n      });\n    });\n  },\n\n  /**\n   * Replaces the top item and pop to it.\n   * @param route The new route that will replace the topmost item.\n   */\n  resetTo: function(route: Route) {\n    invariant(!!route, 'Must supply route to push');\n    // Make sure all previous requests are caught up first. Otherwise reject.\n    if (this.state.requestedTopOfStack !== this.state.observedTopOfStack) {\n      return;\n    }\n    this.replaceAtIndex(route, 0);\n    this.popToRoute(route);\n  },\n\n  _handleNavigationComplete: function(e: Event) {\n    // Don't propagate to other NavigatorIOS instances this is nested in:\n    e.stopPropagation();\n\n    if (this._toFocusOnNavigationComplete) {\n      this._getFocusEmitter().emit('focus', this._toFocusOnNavigationComplete);\n      this._toFocusOnNavigationComplete = null;\n    }\n    this._handleNavigatorStackChanged(e);\n  },\n\n  _routeToStackItem: function(routeArg: Route, i: number) {\n    var {component, wrapperStyle, passProps, ...route} = routeArg;\n    var {itemWrapperStyle, ...props} = this.props;\n    var shouldUpdateChild =\n      this.state.updatingAllIndicesAtOrBeyond != null &&\n      this.state.updatingAllIndicesAtOrBeyond >= i;\n    var Component = component;\n    return (\n      <StaticContainer key={'nav' + i} shouldUpdate={shouldUpdateChild}>\n        <RCTNavigatorItem\n          {...props}\n          {...route}\n          style={[\n            styles.stackItem,\n            itemWrapperStyle,\n            wrapperStyle\n          ]}>\n          <Component\n            navigator={this.navigator}\n            route={route}\n            {...passProps}\n          />\n        </RCTNavigatorItem>\n      </StaticContainer>\n    );\n  },\n\n  _renderNavigationStackItems: function() {\n    var shouldRecurseToNavigator =\n      this.state.makingNavigatorRequest ||\n      this.state.updatingAllIndicesAtOrBeyond !== null;\n    // If not recursing update to navigator at all, may as well avoid\n    // computation of navigator children.\n    var items = shouldRecurseToNavigator ?\n      this.state.routeStack.map(this._routeToStackItem) : null;\n    return (\n      <StaticContainer shouldUpdate={shouldRecurseToNavigator}>\n        <NavigatorTransitionerIOS\n          ref={TRANSITIONER_REF}\n          style={styles.transitioner}\n          // $FlowFixMe(>=0.41.0)\n          vertical={this.props.vertical}\n          requestedTopOfStack={this.state.requestedTopOfStack}\n          onNavigationComplete={this._handleNavigationComplete}\n          interactivePopGestureEnabled={this.props.interactivePopGestureEnabled}>\n          {items}\n        </NavigatorTransitionerIOS>\n      </StaticContainer>\n    );\n  },\n\n  _tvEventHandler: (undefined: ?TVEventHandler),\n\n  _enableTVEventHandler: function() {\n    this._tvEventHandler = new TVEventHandler();\n    this._tvEventHandler.enable(this, function(cmp, evt) {\n      if (evt && evt.eventType === 'menu') {\n        cmp.pop();\n      }\n    });\n  },\n\n  _disableTVEventHandler: function() {\n    if (this._tvEventHandler) {\n      this._tvEventHandler.disable();\n      delete this._tvEventHandler;\n    }\n  },\n\n  render: function() {\n    return (\n      // $FlowFixMe(>=0.41.0)\n      <View style={this.props.style}>\n        {this._renderNavigationStackItems()}\n      </View>\n    );\n  },\n});\n\nvar styles = StyleSheet.create({\n  stackItem: {\n    backgroundColor: 'white',\n    overflow: 'hidden',\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0,\n  },\n  transitioner: {\n    flex: 1,\n  },\n});\n\nvar RCTNavigator = requireNativeComponent('RCTNavigator');\nvar RCTNavigatorItem = requireNativeComponent('RCTNavItem');\n\nmodule.exports = NavigatorIOS;\n"]}